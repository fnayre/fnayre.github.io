<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.6cde349a8e8a1fa7b83e.css" id="gatsby-global-css">@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:100;src:local("Montserrat Thin "),local("Montserrat-Thin"),url(/static/montserrat-latin-100-8d7d79679b70dbe27172b6460e7a7910.woff2) format("woff2"),url(/static/montserrat-latin-100-ec38980a9e0119a379e2a9b3dbb1901a.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:italic;font-weight:100;src:local("Montserrat Thin italic"),local("Montserrat-Thinitalic"),url(/static/montserrat-latin-100italic-e279051046ba1286706adc886cf1c96b.woff2) format("woff2"),url(/static/montserrat-latin-100italic-3b325a3173c8207435cd1b76e19bf501.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:200;src:local("Montserrat Extra Light "),local("Montserrat-Extra Light"),url(/static/montserrat-latin-200-9d266fbbfa6cab7009bd56003b1eeb67.woff2) format("woff2"),url(/static/montserrat-latin-200-2d8ba08717110d27122e54c34b8a5798.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:italic;font-weight:200;src:local("Montserrat Extra Light italic"),local("Montserrat-Extra Lightitalic"),url(/static/montserrat-latin-200italic-6e5b3756583bb2263eb062eae992735e.woff2) format("woff2"),url(/static/montserrat-latin-200italic-a0d6f343e4b536c582926255367a57da.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:300;src:local("Montserrat Light "),local("Montserrat-Light"),url(/static/montserrat-latin-300-00b3e893aab5a8fd632d6342eb72551a.woff2) format("woff2"),url(/static/montserrat-latin-300-ea303695ceab35f17e7d062f30e0173b.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:italic;font-weight:300;src:local("Montserrat Light italic"),local("Montserrat-Lightitalic"),url(/static/montserrat-latin-300italic-56f34ea368f6aedf89583d444bbcb227.woff2) format("woff2"),url(/static/montserrat-latin-300italic-54b0bf2c8c4c12ffafd803be2466a790.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:400;src:local("Montserrat Regular "),local("Montserrat-Regular"),url(/static/montserrat-latin-400-b71748ae4f80ec8c014def4c5fa8688b.woff2) format("woff2"),url(/static/montserrat-latin-400-0659a9f4e90db5cf51b50d005bff1e41.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:italic;font-weight:400;src:local("Montserrat Regular italic"),local("Montserrat-Regularitalic"),url(/static/montserrat-latin-400italic-6eed6b4cbb809c6efc7aa7ddad6dbe3e.woff2) format("woff2"),url(/static/montserrat-latin-400italic-7583622cfde30ae49086d18447ab28e7.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:500;src:local("Montserrat Medium "),local("Montserrat-Medium"),url(/static/montserrat-latin-500-091b209546e16313fd4f4fc36090c757.woff2) format("woff2"),url(/static/montserrat-latin-500-edd311588712a96bbf435fad264fff62.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:italic;font-weight:500;src:local("Montserrat Medium italic"),local("Montserrat-Mediumitalic"),url(/static/montserrat-latin-500italic-c90ced68b46050061d1a41842d6dfb43.woff2) format("woff2"),url(/static/montserrat-latin-500italic-5146cbfe02b1deea5dffea27a5f2f998.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:600;src:local("Montserrat SemiBold "),local("Montserrat-SemiBold"),url(/static/montserrat-latin-600-0480d2f8a71f38db8633b84d8722e0c2.woff2) format("woff2"),url(/static/montserrat-latin-600-b77863a375260a05dd13f86a1cee598f.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:italic;font-weight:600;src:local("Montserrat SemiBold italic"),local("Montserrat-SemiBolditalic"),url(/static/montserrat-latin-600italic-cf46ffb11f3a60d7df0567f8851a1d00.woff2) format("woff2"),url(/static/montserrat-latin-600italic-c4fcfeeb057724724097167e57bd7801.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:700;src:local("Montserrat Bold "),local("Montserrat-Bold"),url(/static/montserrat-latin-700-7dbcc8a5ea2289d83f657c25b4be6193.woff2) format("woff2"),url(/static/montserrat-latin-700-99271a835e1cae8c76ef8bba99a8cc4e.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:italic;font-weight:700;src:local("Montserrat Bold italic"),local("Montserrat-Bolditalic"),url(/static/montserrat-latin-700italic-c41ad6bdb4bd504a843d546d0a47958d.woff2) format("woff2"),url(/static/montserrat-latin-700italic-6779372f04095051c62ed36bc1dcc142.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:800;src:local("Montserrat ExtraBold "),local("Montserrat-ExtraBold"),url(/static/montserrat-latin-800-db9a3e0ba7eaea32e5f55328ace6cf23.woff2) format("woff2"),url(/static/montserrat-latin-800-4e3c615967a2360f5db87d2f0fd2456f.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:italic;font-weight:800;src:local("Montserrat ExtraBold italic"),local("Montserrat-ExtraBolditalic"),url(/static/montserrat-latin-800italic-bf45bfa14805969eda318973947bc42b.woff2) format("woff2"),url(/static/montserrat-latin-800italic-fe82abb0bcede51bf724254878e0c374.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:900;src:local("Montserrat Black "),local("Montserrat-Black"),url(/static/montserrat-latin-900-e66c7edc609e24bacbb705175669d814.woff2) format("woff2"),url(/static/montserrat-latin-900-8211f418baeb8ec880b80ba3c682f957.woff) format("woff")}@font-face{font-display:swap;font-family:Montserrat;font-style:italic;font-weight:900;src:local("Montserrat Black italic"),local("Montserrat-Blackitalic"),url(/static/montserrat-latin-900italic-4454c775e48152c1a72510ceed3603e2.woff2) format("woff2"),url(/static/montserrat-latin-900italic-efcaa0f6a82ee0640b83a0916e6e8d68.woff) format("woff")}@font-face{font-display:swap;font-family:Merriweather;font-style:normal;font-weight:300;src:local("Merriweather Light "),local("Merriweather-Light"),url(/static/merriweather-latin-300-fc117160c69a8ea0851b26dd14748ee4.woff2) format("woff2"),url(/static/merriweather-latin-300-58b18067ebbd21fda77b67e73c241d3b.woff) format("woff")}@font-face{font-display:swap;font-family:Merriweather;font-style:italic;font-weight:300;src:local("Merriweather Light italic"),local("Merriweather-Lightitalic"),url(/static/merriweather-latin-300italic-fe29961474f8dbf77c0aa7b9a629e4bc.woff2) format("woff2"),url(/static/merriweather-latin-300italic-23c3f1f88683618a4fb8d265d33d383a.woff) format("woff")}@font-face{font-display:swap;font-family:Merriweather;font-style:normal;font-weight:400;src:local("Merriweather Regular "),local("Merriweather-Regular"),url(/static/merriweather-latin-400-d9479e8023bef9cbd9bf8d6eabd6bf36.woff2) format("woff2"),url(/static/merriweather-latin-400-040426f99ff6e00b86506452e0d1f10b.woff) format("woff")}@font-face{font-display:swap;font-family:Merriweather;font-style:italic;font-weight:400;src:local("Merriweather Regular italic"),local("Merriweather-Regularitalic"),url(/static/merriweather-latin-400italic-2de7bfeaf08fb03d4315d49947f062f7.woff2) format("woff2"),url(/static/merriweather-latin-400italic-79db67aca65f5285964ab332bd65f451.woff) format("woff")}@font-face{font-display:swap;font-family:Merriweather;font-style:normal;font-weight:700;src:local("Merriweather Bold "),local("Merriweather-Bold"),url(/static/merriweather-latin-700-4b08e01d805fa35d7bf777f1b24314ae.woff2) format("woff2"),url(/static/merriweather-latin-700-22fb8afba4ab1f093b6ef9e28a9b6e92.woff) format("woff")}@font-face{font-display:swap;font-family:Merriweather;font-style:italic;font-weight:700;src:local("Merriweather Bold italic"),local("Merriweather-Bolditalic"),url(/static/merriweather-latin-700italic-cd92541b177652fffb6e3b952f1c33f1.woff2) format("woff2"),url(/static/merriweather-latin-700italic-f87f3d87cea0dd0979bfc8ac9ea90243.woff) format("woff")}@font-face{font-display:swap;font-family:Merriweather;font-style:normal;font-weight:900;src:local("Merriweather Black "),local("Merriweather-Black"),url(/static/merriweather-latin-900-f813fc6a4bee46eda5224ac7ebf1b7be.woff2) format("woff2"),url(/static/merriweather-latin-900-5d4e42cb44410674acd99153d57df032.woff) format("woff")}@font-face{font-display:swap;font-family:Merriweather;font-style:italic;font-weight:900;src:local("Merriweather Black italic"),local("Merriweather-Blackitalic"),url(/static/merriweather-latin-900italic-b7901d85486871c1779c0e93ddd85656.woff2) format("woff2"),url(/static/merriweather-latin-900italic-9647f9fdab98756989a8a5550eb205c3.woff) format("woff")}


/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{-webkit-text-size-adjust:100%;line-height:1.15}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden]{display:none}:root{--maxWidth-none:"none";--maxWidth-xs:20rem;--maxWidth-sm:24rem;--maxWidth-md:28rem;--maxWidth-lg:32rem;--maxWidth-xl:36rem;--maxWidth-2xl:42rem;--maxWidth-3xl:48rem;--maxWidth-4xl:56rem;--maxWidth-full:"100%";--maxWidth-wrapper:var(--maxWidth-2xl);--spacing-px:"1px";--spacing-0:0;--spacing-1:0.25rem;--spacing-2:0.5rem;--spacing-3:0.75rem;--spacing-4:1rem;--spacing-5:1.25rem;--spacing-6:1.5rem;--spacing-8:2rem;--spacing-10:2.5rem;--spacing-12:3rem;--spacing-16:4rem;--spacing-20:5rem;--spacing-24:6rem;--spacing-32:8rem;--fontFamily-sans:Montserrat,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--fontFamily-serif:"Merriweather","Georgia",Cambria,"Times New Roman",Times,serif;--font-body:var(--fontFamily-serif);--font-heading:var(--fontFamily-sans);--fontWeight-normal:400;--fontWeight-medium:500;--fontWeight-semibold:600;--fontWeight-bold:700;--fontWeight-extrabold:800;--fontWeight-black:900;--fontSize-root:16px;--lineHeight-none:1;--lineHeight-tight:1.1;--lineHeight-normal:1.5;--lineHeight-relaxed:1.625;--fontSize-0:0.833rem;--fontSize-1:1rem;--fontSize-2:1.2rem;--fontSize-3:1.44rem;--fontSize-4:1.728rem;--fontSize-5:2.074rem;--fontSize-6:2.488rem;--fontSize-7:2.986rem;--color-primary:#005b99;--color-text:#2e353f;--color-text-light:#4f5969;--color-heading:#1a202c;--color-heading-black:#000;--color-accent:#d1dce5}*,:after,:before{box-sizing:border-box}html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-size:var(--fontSize-root);line-height:var(--lineHeight-normal)}body{color:var(--color-text);font-family:var(--font-body);font-size:var(--fontSize-1)}footer{padding:var(--spacing-6) var(--spacing-0)}hr{background:var(--color-accent);border:0;height:1px}h1,h2,h3,h4,h5,h6{font-family:var(--font-heading);letter-spacing:-.025em;line-height:var(--lineHeight-tight);margin-bottom:var(--spacing-6);margin-top:var(--spacing-12)}h2,h3,h4,h5,h6{color:var(--color-heading);font-weight:var(--fontWeight-bold)}h1{color:var(--color-heading-black);font-size:var(--fontSize-6);font-weight:var(--fontWeight-black)}h2{font-size:var(--fontSize-5)}h3{font-size:var(--fontSize-4)}h4{font-size:var(--fontSize-3)}h5{font-size:var(--fontSize-2)}h6{font-size:var(--fontSize-1)}h1>a,h2>a,h3>a,h4>a,h5>a,h6>a{color:inherit;text-decoration:none}p{--baseline-multiplier:0.179;--x-height-multiplier:0.35;line-height:var(--lineHeight-relaxed);margin:var(--spacing-0) var(--spacing-0) var(--spacing-8) var(--spacing-0)}ol,p,ul{padding:var(--spacing-0)}ol,ul{list-style-image:none;list-style-position:outside;margin-bottom:var(--spacing-8);margin-left:var(--spacing-0);margin-right:var(--spacing-0)}ol li,ul li{padding-left:var(--spacing-0)}li>p,ol li,ul li{margin-bottom:calc(var(--spacing-8)/2)}li :last-child{margin-bottom:var(--spacing-0)}li>ul{margin-left:var(--spacing-8);margin-top:calc(var(--spacing-8)/2)}blockquote{border-left:var(--spacing-1) solid var(--color-primary);color:var(--color-text-light);font-size:var(--fontSize-2);font-style:italic;margin-bottom:var(--spacing-8);margin-left:calc(var(--spacing-6)*-1);margin-right:var(--spacing-8);padding:var(--spacing-0) var(--spacing-0) var(--spacing-0) var(--spacing-6)}blockquote>:last-child{margin-bottom:var(--spacing-0)}blockquote>ol,blockquote>ul{list-style-position:inside}table{border-collapse:collapse;border-spacing:.25rem;margin-bottom:var(--spacing-8);width:100%}table thead tr th{border-bottom:1px solid var(--color-accent)}a{color:var(--color-primary)}a:focus,a:hover{text-decoration:none}.global-wrapper{margin:var(--spacing-0) auto;max-width:var(--maxWidth-wrapper);padding:var(--spacing-10) var(--spacing-5)}.global-wrapper[data-is-root-path=true] .bio{margin-bottom:var(--spacing-20)}.global-header{margin-bottom:var(--spacing-12)}.main-heading{font-size:var(--fontSize-7);margin:0}.post-list-item{margin-bottom:var(--spacing-8);margin-top:var(--spacing-8)}.post-list-item p{margin-bottom:var(--spacing-0)}.post-list-item h2{color:var(--color-primary);font-size:var(--fontSize-4);margin-bottom:var(--spacing-2);margin-top:var(--spacing-0)}.post-list-item header{margin-bottom:var(--spacing-4)}.header-link-home{font-family:var(--font-heading);font-size:var(--fontSize-2);font-weight:var(--fontWeight-bold);text-decoration:none}.bio{display:flex;margin-bottom:var(--spacing-16)}.bio-avatar,.bio p{margin-bottom:var(--spacing-0)}.bio-avatar{border-radius:100%;margin-right:var(--spacing-4);min-width:50px}.blog-post header h1{margin:var(--spacing-0) var(--spacing-0) var(--spacing-4) var(--spacing-0)}.blog-post header p{font-family:var(--font-heading);font-size:var(--fontSize-2)}.blog-post-nav ul{margin:var(--spacing-0)}.gatsby-highlight{margin-bottom:var(--spacing-8)}@media (max-width:42rem){blockquote{margin-left:var(--spacing-0);padding:var(--spacing-0) var(--spacing-0) var(--spacing-0) var(--spacing-4)}ol,ul{list-style-position:inside}}code[class*=language-],pre[class*=language-]{color:#393a34;direction:ltr;font-family:Consolas,Bitstream Vera Sans Mono,Courier New,Courier,monospace;font-size:.9em;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;line-height:1.2em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre>code[class*=language-]{font-size:1em}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#c1def1}pre[class*=language-]{background-color:#f6f8fa;border-radius:6px;margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-]{background-color:#1b1f230d;border-radius:4px;padding:1px .2em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:green;font-style:italic}.token.namespace{opacity:.7}.token.string{color:#a31515}.token.operator,.token.punctuation{color:#393a34}.token.boolean,.token.constant,.token.inserted,.token.number,.token.symbol,.token.url,.token.variable{color:#36acaa}.language-autohotkey .token.selector,.language-json .token.boolean,.language-json .token.number,.token.atrule,.token.attr-value,.token.keyword,code[class*=language-css]{color:#00f}.token.function{color:#393a34}.language-autohotkey .token.tag,.token.deleted{color:#9a050f}.language-autohotkey .token.keyword,.token.selector{color:#00009f}.token.important{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.language-json .token.property,.token.class-name{color:#2b91af}.token.selector,.token.tag{color:maroon}.token.attr-name,.token.entity,.token.property,.token.regex{color:red}.token.directive.tag .tag{background:#ff0;color:#393a34}.line-numbers .line-numbers-rows{border-right-color:#a5a5a5}.line-numbers-rows>span:before{color:#2b91af}.line-highlight{background:rgba(193,222,241,.2);background:linear-gradient(90deg,rgba(193,222,241,.2) 70%,rgba(221,222,241,0))}</style><meta name="generator" content="Gatsby 3.6.2"/><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><link rel="icon" href="/favicon-32x32.png?v=4a9773549091c227cd2eb82ccd9c5e3a" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><title data-react-helmet="true">Types as Propositions in Typescript | Abstract fun</title><meta data-react-helmet="true" name="description" content="Propositions as types correspondance (PAT) (or Types as Propositions) is one of the most 
intriguing discoveries of Computer Science. The gist of it is: In…"/><meta data-react-helmet="true" property="og:title" content="Types as Propositions in Typescript"/><meta data-react-helmet="true" property="og:description" content="Propositions as types correspondance (PAT) (or Types as Propositions) is one of the most 
intriguing discoveries of Computer Science. The gist of it is: In…"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="YassineElouafi2"/><meta data-react-helmet="true" name="twitter:title" content="Types as Propositions in Typescript"/><meta data-react-helmet="true" name="twitter:description" content="Propositions as types correspondance (PAT) (or Types as Propositions) is one of the most 
intriguing discoveries of Computer Science. The gist of it is: In…"/><link as="script" rel="preload" href="/webpack-runtime-787195f1393efa40968d.js"/><link as="script" rel="preload" href="/framework-c4b9952841844d9091bc.js"/><link as="script" rel="preload" href="/app-be01091e8f6277f5b6f6.js"/><link as="script" rel="preload" href="/commons-140fdb61bcb6fdaf6bd2.js"/><link as="script" rel="preload" href="/component---src-templates-blog-post-js-664fa24895fa0bb62323.js"/><link as="fetch" rel="preload" href="/page-data/2023-09-04-pat/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2841359383.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/3257411868.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="global-wrapper" data-is-root-path="false"><header class="global-header"><a class="header-link-home" href="/">Abstract fun</a></header><main><article class="blog-post" itemscope="" itemType="http://schema.org/Article"><header><h1 itemProp="headline">Types as Propositions in Typescript</h1><p>September 05, 2023</p></header><section itemProp="articleBody"><p>Propositions as types correspondance (PAT) (or Types as Propositions) is one of the most
intriguing discoveries of Computer Science. The gist of it is:</p>
<ul>
<li>In Logic land, you often see stuff like <code class="language-text">P is True</code>. Here, <code class="language-text">P</code> can stand for some
statement that can be true or false. And a Proof is constructed to back the statement.</li>
<li>In code, we’ve got something like: <code class="language-text">let x: T = term;</code>.</li>
</ul>
<p>The correspondance is basically saying Logic and Programming are two sides of the same coin:</p>
<ul>
<li>In Logic: When you claim something is true, you must provide a Proof for it.</li>
<li>In code: If you got a type and want to use it, you create a term of that type.</li>
</ul>
<p>It’s as if we were writing <code class="language-text">let x: P = proof;</code> in TypeScript. And it’s not just some
quirky coincidence. If we restrict ourself to a pure subset TypeScript, you’ll see
you can write logical proofs using code.</p>
<h2>Code’s Take on Logic Constructs</h2>
<p>First let’s review quickly the key concepts in Logic, they work pretty much like the booleans
we use in programming:</p>
<ul>
<li><code class="language-text">True</code> or <code class="language-text">⊤</code>: This represents a proposition that’s always true. </li>
<li><code class="language-text">False</code> or <code class="language-text">⊥</code>: signifies something that’s never true.</li>
<li><code class="language-text">A ∨ B</code> : A disjunction. True if either <code class="language-text">A</code> or <code class="language-text">B</code> hold true. Could be both.</li>
<li><code class="language-text">A ∧ B</code> : A conjunction. Both <code class="language-text">A</code> and <code class="language-text">B</code> must be true.</li>
<li><code class="language-text">A -&gt; B</code> : Logical implication. If <code class="language-text">A</code> is true, then <code class="language-text">B</code> is consequently true.</li>
<li><code class="language-text">!A</code> : negation, a Proposition that’s true if <code class="language-text">A</code> is not.</li>
</ul>
<p>There’s also <code class="language-text">A &lt;=&gt; B</code>. It’s essentially stating that <code class="language-text">A</code> implies <code class="language-text">B</code> and <code class="language-text">B</code> implies <code class="language-text">A</code>.
In other words, <code class="language-text">(A -&gt; B) ∧ (B -&gt; A)</code>. </p>
<p>Now for each one of the above constructs we have an equivalent type in Typescript.</p>
<p><code class="language-text">True</code> corresponds to any inhabitated type</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">True</span> <span class="token operator">=</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span></code></pre></div>
<blockquote>
<blockquote>
<p>We could use a singleton type like <code class="language-text">null</code> or <code class="language-text">undefined</code>. But with the <code class="language-text">unknown</code> type,
we can assign any value to it.</p>
</blockquote>
</blockquote>
<p><code class="language-text">False</code> translates to an uninhabited type in TypeScript. This mirrors the fact that there’s no
proof for a false proposition in Logic:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">False</span> <span class="token operator">=</span> <span class="token builtin">never</span><span class="token punctuation">;</span></code></pre></div>
<p><code class="language-text">A ∨ B</code> corresponds to a discriminated union type in TypeScript. </p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">Or<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> 
  <span class="token operator">|</span> <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">"left"</span><span class="token punctuation">;</span> value<span class="token operator">:</span> <span class="token constant">A</span> <span class="token punctuation">}</span> 
  <span class="token operator">|</span> <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">"right"</span><span class="token punctuation">;</span> value<span class="token operator">:</span> <span class="token constant">B</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>We’ll also write two constructor functions:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">left</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token operator">:</span> Or<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token builtin">never</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">"left"</span><span class="token punctuation">,</span> value <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">right</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">B</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span><span class="token operator">:</span> Or<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">"right"</span><span class="token punctuation">,</span> value <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>And a helper for case analysis:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">either</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  or<span class="token operator">:</span> Or<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span><span class="token punctuation">,</span>
  <span class="token function-variable function">onLeft</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">C</span><span class="token punctuation">,</span>
  <span class="token function-variable function">onRight</span><span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">C</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">C</span> <span class="token punctuation">{</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    or<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">"left"</span> 
      <span class="token operator">?</span> <span class="token function">onLeft</span><span class="token punctuation">(</span>or<span class="token punctuation">.</span>value<span class="token punctuation">)</span> 
      <span class="token operator">:</span> <span class="token function">onRight</span><span class="token punctuation">(</span>or<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">A ∧ B</code> corresponds to a pair of types:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">And<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></div>
<p>Logical implications translate to function types:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">Imp<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">B</span><span class="token punctuation">;</span></code></pre></div>
<p>Finally, The equivalence <code class="language-text">A &lt;=&gt; B</code> corresponds to a pair of 2 functions.
It’s a sort of 2-way conversion between <code class="language-text">A</code> and <code class="language-text">B</code></p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">Iff<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">[</span>Imp<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span><span class="token punctuation">,</span> Imp<span class="token operator">&lt;</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></div>
<p>So far, everything’s been kinda familiar, right? But with negation, things are getting a bit wild.</p>
<h2>Negative types</h2>
<p>Let’s start by unpacking the meaning of <code class="language-text">False</code>/<code class="language-text">never</code>. The <code class="language-text">never</code> type acts as a universal subtype,
as it can be assigned to any other type.</p>
<p>You might wonder about the meaning of <code class="language-text">any</code> here. Intriguingly, <code class="language-text">any</code> stands as a proposition
that is both <code class="language-text">True</code> and <code class="language-text">False</code> at once. This duality allows any value to be assigned to it,
making it akin to <code class="language-text">unknown</code> or <code class="language-text">True</code>. On the flip side, it can fit into any type (except <code class="language-text">never</code>),
reflecting the nature of <code class="language-text">never</code> or <code class="language-text">False</code>.</p>
<p>In logical discourse, a proposition that holds as true and false simultaneously is labeled
a <em>contradiction</em>. If one can prove a contradiction,  the whole logic system just falls apart.
In a parallel sense, being able to produce terms of type <code class="language-text">any</code> compromises the
soundness of the type system. As highlighted in the TypeScript documentation, the
flexibility of <code class="language-text">any</code> sacrifices type safety. </p>
<p>This brings us to the concept of <strong>Proof by contradiction</strong>: To disprove a proposition <code class="language-text">A</code>
(or to assert <code class="language-text">!A</code>), one assumes <code class="language-text">A</code> is true and then demonstrates that this assumption leads
to a contradiction.. In essence, <code class="language-text">!A</code> equates to <code class="language-text">A -&gt; False</code>.</p>
<p>Hence, negating a type <code class="language-text">A</code> in TypeScript translates to the function <code class="language-text">(x: A) =&gt; never</code>.</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">Not<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">never</span><span class="token punctuation">;</span></code></pre></div>
<h2>Double negation, paradoxes and the halting problem</h2>
<p>Constructing a term of type <code class="language-text">A -&gt; never</code> poses challenges though. How can we return a <code class="language-text">never</code> value when,
by definition, <code class="language-text">never</code> lacks any values?</p>
<p>One way to produce a negative type in Typescript is by writing a non terminating function. For example: </p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">forever</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">forever</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// typeof forever = &lt;A>(a: A) => never</span></code></pre></div>
<p>Typesript detects that the function never terminates and assigns to it a type of <code class="language-text">&lt;A&gt;(a: A) =&gt; never</code>.
(There are alternative methods to create functions that don’t return,
but remember we’re operating within a limited TypeScript subset here).</p>
<p>Is this type designation genuinely <em>accurate</em> from a logical standpoint?</p>
<p>Consider the following function</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">double_neg</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">ff</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">never</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">never</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">A</span> <span class="token punctuation">{</span>
  <span class="token comment">//</span>
  <span class="token keyword">function</span> <span class="token function">wait_forever</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">wait_forever</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token function">ff</span><span class="token punctuation">(</span>wait_forever<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>A closer look at the type reveals it corresponds to <code class="language-text">Not&lt;Not&lt;A&gt;&gt; =&gt; A</code>. This is just the <em>double
negation law</em> in Logic: <code class="language-text">!!A = A</code>. </p>
<p>The implementation exploits the fact that <code class="language-text">never</code> can be assigned to any type <code class="language-text">A</code>. Now we should
be able to use our double negation in our code to turn values of type <code class="language-text">!!A</code> into values of type <code class="language-text">A</code>:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">double_neg</span><span class="token punctuation">(</span>k <span class="token operator">=></span> <span class="token function">k</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span></code></pre></div>
<p>However an issue arises:  the statement <code class="language-text">let b = a + 2;</code> is never reached. Upon entering <code class="language-text">double_neg</code>, the body
invokes <code class="language-text">k(5)</code> where <code class="language-text">k</code> represents the non terminating function <code class="language-text">wait_forever</code>. The program remains trapped
there indefinitely.</p>
<p>The core issue with <code class="language-text">wait_forever</code> is its endless recursion. It’s like an infinite loop that keeps
running without an exit condition. In Logic, infinite loops can give birth to tricky paradoxes,
like this classic:</p>
<blockquote>
<blockquote>
<p>This statement is false</p>
</blockquote>
</blockquote>
<p>This is the essence of the <em>liar paradox</em>. If you try to reason through it, you’ll get stuck in
a endless cycle of contradictions. Give it a try!</p>
<ol>
<li><strong>If we assume that <code class="language-text">statement</code> is true</strong>, then the statement
must be false as it claims to be. But then it contradicts our own assumption that
the statement was true.</li>
<li><strong>If we assume that <code class="language-text">statement</code> is false</strong>, then it’s ironically being truthful
about its falsehood, making it true. Again, this is a contradiction because we
just assumed it was false.</li>
</ol>
<p>The self-referencing nature of the statement is the real troublemaker here. It creates a
loop where the truth value keeps toggling between true and false, never settling, similar
to how a piece of code is stuck in an infinite loop.</p>
<p>This is bad for Logic, which requires every proof to be finite. What this says in reality is
that <code class="language-text">wait_forever</code> is not exactly the function we’re seeking for our negative types.</p>
<p>A more Logic freindly interpretation of negation is actually possible, and would allow writing programs
in <em>double negation style</em>. To see how, let’s revisit our earlier example:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">double_neg</span><span class="token punctuation">(</span>k <span class="token operator">=></span> <span class="token function">k</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span></code></pre></div>
<p>The double negation principle, <code class="language-text">!!A = A</code>, hints that the program should progress beyond the initial line,
assigning a number type to <code class="language-text">a</code>. Which number? In this context, <code class="language-text">5</code> seems like a logical choice.</p>
<p>But then, what’s the role of the <code class="language-text">k</code> argument, and how do we instantiate it?</p>
<p>Here’s the twist: <code class="language-text">k</code> isn’t a function we can implement by ourselves. <strong>It has to be provided</strong>
to us by the programming language.</p>
<p>This isn’t just a normal function, It belongs to a special
class known as <em>continuations</em>. Think of a continuation as a snapshot of a program’s
future from a particular moment. For example, consider this code:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token comment">// assume f : (n: number) => number</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span></code></pre></div>
<p>Now, let’s transform it into a continuation-passing style (CPS):</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>

  <span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></div>
<p>In the CPS style, every function receives an extra <code class="language-text">k</code> argument, which represents the program’s subsequent steps.</p>
<p>Our <code class="language-text">double_neg</code>, by converting from <code class="language-text">Not&lt;Not&lt;A&gt;&gt;</code> to <code class="language-text">A</code>, essentially transforms a CPS function call into
a standard value of type <code class="language-text">A</code>. It achieves this by encapsulating the program’s future steps and repackaging
them into a function awaiting a value to proceed.</p>
<p>While non-terminating functions and continuations both return <code class="language-text">never</code>, continuations avoid
embedding self-referential inconsistencies <strong>within</strong> our system. By the time the
function concludes, the program has also concluded.</p>
<p>That means to make values of type <code class="language-text">Not&lt;A&gt;</code>, our programming language should equip us with
something to encapsulate the program’s subsequent steps as a continuation. </p>
<p>Although TypeScript doesn’t natively support this construct, for the sake of discussion,
let’s pretend it does:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">double_neg</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>f<span class="token operator">:</span> Not<span class="token operator">&lt;</span>Not<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">>></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">;</span></code></pre></div>
<blockquote>
<blockquote>
<p>While the double negation principle might feel intuitive, I should mention it’s not something
universally accepted. Some logicians believe that just because a statement isn’t proven doesn’t
mean the opposite holds true. Think of it as “absence of evidence isn’t evidence of absence.”
This viewpoint is held by <em>intuitionistic logic</em>.</p>
<p>In contrast <em>classical Logic</em> embraces the double negation law. But as we’ve observed,
to embed this principle in a programming language, we need a control operator to
turn double negation into identity. This hints at a deep connection between the context
in which a program runs and the foundational logic underpinning it.</p>
</blockquote>
</blockquote>
<p>If you’ve dabbled with Lisp-like languages (like Scheme or Clojure), you might’ve bumped
into a cousin of <code class="language-text">double_neg</code> named <code class="language-text">call/cc</code> (though its type is a bit different).</p>
<h2>Diving into Logical Proofs using TypeScript</h2>
<p>Having established a bridge between Logic’s concepts and our TypeScript subset,
We’re ready to weild this knowledge to perform some common proofs in Logic.</p>
<p>The most elementary proof is the tautology <code class="language-text">A =&gt; A</code>. This is just the identity function</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">id</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Let’s see some more interesting proofs.</p>
<p>We’ll define all our proofs in a generic function, to abstract over propostions <code class="language-text">A</code> and <code class="language-text">B</code>.</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">context</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//</span>
  <span class="token keyword">type</span> <span class="token class-name">NotA</span> <span class="token operator">=</span> Not<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span><span class="token punctuation">;</span>

  <span class="token keyword">type</span> <span class="token class-name">NotB</span> <span class="token operator">=</span> Not<span class="token operator">&lt;</span><span class="token constant">B</span><span class="token operator">></span><span class="token punctuation">;</span>

  <span class="token comment">// ... subsequent proofs will be populated here</span>
<span class="token punctuation">}</span></code></pre></div>
<h3>Law of Excluded Middle (<code class="language-text">A ∨ !A &lt;=&gt; True</code>)</h3>
<p>The law of excluded middle is a foundational principle in classical logic,
which asserts that any proposition is either true or its negation is true.
There’s no in-between state.</p>
<p>Let’s first write the implementation:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token comment">// A ∨ !A</span>
<span class="token keyword">const</span> excluded_middle<span class="token operator">:</span> Or<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> NotA<span class="token operator">></span> <span class="token operator">=</span> 
  <span class="token function">double_neg</span><span class="token punctuation">(</span>k <span class="token operator">=></span> 
    <span class="token function">k</span><span class="token punctuation">(</span><span class="token function">right</span><span class="token punctuation">(</span>a <span class="token operator">=></span> 
      <span class="token function">k</span><span class="token punctuation">(</span><span class="token function">left</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>To construct a value of type <code class="language-text">A ∨ !A</code>, we have 2 choices:</p>
<ol>
<li>Constructing <code class="language-text">A</code>: Creating an instance of an arbitrary type <code class="language-text">A</code> is unfeasible.
It’s like attempting to materialize something from nothing.</li>
<li>On the other hand, creating an instance of <code class="language-text">!A</code> is feasible. To understand
this, recall that <code class="language-text">!A</code> is synonymous with a continuation of type <code class="language-text">(a:A) -&gt; never</code>.
So we’ll need the help of <code class="language-text">double_neg</code>.</li>
</ol>
<p>Here’s the step-by-step breakdown of the implementation:</p>
<ol>
<li>Invoke <code class="language-text">double_neg</code> and capture the current continuation as <code class="language-text">k</code>.</li>
<li>Inside the continuation, the next plausible action is to make use
of <code class="language-text">right</code> to indicate we’re choosing the negation path. This gives: <code class="language-text">k(right(a =&gt; _))</code>.</li>
<li>Now, inside our function <code class="language-text">(a =&gt; _)</code>, we need to return a value of type <code class="language-text">never</code>.
The one tool we have at our disposal to achieve this effect is the captured
continuation <code class="language-text">k</code>. Since we now have access to a value of type <code class="language-text">A</code> (through the function argument),
we can use <code class="language-text">k</code> to redirect our flow to the other branch, i.e., <code class="language-text">left(A)</code>.
This is expressed as: <code class="language-text">k(left(a))</code>.</li>
</ol>
<p>This construction can look mind-bending, especially if encountered for
the first time. It’s somewhat analogous to a closed time-like loop in physics,
where cause and effect blur.</p>
<p>In <a href="https://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf">one of his papers</a>, Philipe Wadler,
illustrates the above behavior:</p>
<blockquote>
<blockquote>
<p>The following story illustrates this behavior. (With apologies to Peter Selinger,
who tells a similar story about a king,
a wizard, and the Philosopher’s stone.)</p>
<p>Once upon a time, the devil approached a man and made
an offer: “Either (a) I will give you one billion dollars, or (b)
I will grant you any wish if you pay me one billion dollars.
Of course, I get to choose whether I offer (a) or (b).</p>
<p>The man was wary. Did he need to sign over his soul?
No, said the devil, all the man need do is accept the offer.</p>
<p>The man pondered. If he was offered (b) it was unlikely
that he would ever be able to buy the wish, but what was
the harm in having the opportunity available?
“I accept,” said the man at last. “Do I get (a) or (b)?”
The devil paused. “I choose (b).”</p>
<p>The man was disappointed but not surprised. That was
that, he thought. But the offer gnawed at him. Imagine
what he could do with his wish! Many years passed, and
the man began to accumulate money. To get the money he
sometimes did bad things, and dimly he realized that this
must be what the devil had in mind. Eventually he had his
billion dollars, and the devil appeared again.</p>
<p>“Here is a billion dollars,” said the man, handing over a
valise containing the money. “Grant me my wish!”
The devil took possession of the valise. Then he said,
“Oh, did I say (b) before? I’m so sorry. I meant (a). It is
my great pleasure to give you one billion dollars.”</p>
<p>And the devil handed back to the man the same valise
that the man had just handed to him.</p>
</blockquote>
</blockquote>
<p>Lastly, an important takeaway is that the <code class="language-text">double_neg</code> function anchors this logic
in the domain of classical logic. In intuitionistic logic, which is more conservative
about claims of truth or falsity, such a construction might not hold true. Here,
if you cannot furnish a proof for <code class="language-text">A</code>, it doesn’t automatically mean <code class="language-text">A</code> is false.
It simply means that the truth value of <code class="language-text">A</code> remains undetermined.</p>
<h3><code class="language-text">A ∧ !A -&gt; False</code></h3>
<p>A proposition and its negation cannot both be true simultaneously.</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token comment">// A ∧ !A -> False</span>
<span class="token keyword">const</span> neg_law<span class="token operator">:</span> Imp<span class="token operator">&lt;</span>And<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> NotA<span class="token operator">></span><span class="token punctuation">,</span> False<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> notA<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">notA</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>In code, this means we can just smash matter and antimatter together and
watch them annihilate.</p>
<h3>Are Functions Essentially Discriminated Unions?</h3>
<p>Here’s a thought-provoking equivalence:</p>
<p><strong><code class="language-text">A -&gt; B &lt;=&gt; !A ∨ B</code></strong></p>
<p>It basically says a function <code class="language-text">A -&gt; B</code> is equivalent to an union of a
continuation expecting <code class="language-text">A</code> and a value <code class="language-text">B</code>.</p>
<p>Let’s see what this means in code.</p>
<p>From <code class="language-text">(A -&gt; B)</code> to <code class="language-text">(!A ∨ B)</code>:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token comment">// Transition from (A -> B) to (!A ∨ B)</span>
<span class="token keyword">const</span> fn_union_fwd<span class="token operator">:</span> Imp<span class="token operator">&lt;</span>Imp<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span><span class="token punctuation">,</span> Or<span class="token operator">&lt;</span>NotA<span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">>></span> <span class="token operator">=</span> 
  <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">=></span>
    <span class="token function">double_neg</span><span class="token punctuation">(</span>k <span class="token operator">=></span> 
      <span class="token function">k</span><span class="token punctuation">(</span><span class="token function">left</span><span class="token punctuation">(</span>a <span class="token operator">=></span> 
        <span class="token function">k</span><span class="token punctuation">(</span><span class="token function">right</span><span class="token punctuation">(</span>
          <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Utilizing the previous time-traveling maneuver, we initially yield a continuation
to solicit an <code class="language-text">A</code> type. Then we use our <code class="language-text">A -&gt; B</code> function to transform the <code class="language-text">A</code> into a <code class="language-text">B</code> value.
Subsequently, we reinvoke the continuation to yield the result <code class="language-text">B</code> to the surroundings.</p>
<p>Conversely, for the transformation of a union type to a function:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token comment">// Transition from (!A ∨ B) to (A -> B)</span>
<span class="token keyword">const</span> fn_union_bwd<span class="token operator">:</span> Imp<span class="token operator">&lt;</span>Or<span class="token operator">&lt;</span>NotA<span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span><span class="token punctuation">,</span> Imp<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">>></span> <span class="token operator">=</span> 
  notA_or_B <span class="token operator">=></span> 
    a <span class="token operator">=></span>
      <span class="token function">either</span><span class="token punctuation">(</span>
        notA_or_B<span class="token punctuation">,</span>
        <span class="token punctuation">(</span>notA<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">notA</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">=></span> b<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>To morph a union type to a function, we assume an <code class="language-text">A</code> argument. Then based on the
content of our container <code class="language-text">!A ∨ B</code>:</p>
<ul>
<li>If it’s a continuation waiting for an <code class="language-text">A</code>, we just present our <code class="language-text">A</code> argument.</li>
<li>Conversely, if it’s a <code class="language-text">B</code> value, we directly return it.</li>
</ul>
<blockquote>
<blockquote>
<p>This may appear as a form of trickery. One usually expects a genuine mechanism
to turn an <code class="language-text">A</code> into a <code class="language-text">B</code>. Instead, the transformation feels more like
routing around the union, merely forwarding existing information rather than
truly processing it.</p>
<p>To be honest, I don’t really have a plausible explanation. I was thinking it might be because
of classical logic quirks, but the above proof doesn’t use <code class="language-text">double_neg</code> so it’s equally
valid in intuitionistic logic. </p>
<p>I tried to ask my freind GPT-4. Can’t say it adds much but here’s the answer anyway:</p>
<p>“Imagine you have a box that might either contain a machine that needs some input <code class="language-text">A</code>
to work or an already finished product <code class="language-text">B</code>. Now, if someone hands you an <code class="language-text">A</code>, this function
simply checks the box. If there’s a machine (<code class="language-text">notA</code>), it feeds the <code class="language-text">A</code> to it.
If there’s a finished product <code class="language-text">B</code>, it just hands it over. The function doesn’t
do the “creation” part itself, but instead relies on what’s in the box. This doesn’t
feel like a trick anymore; it’s more about delegation and routing based on what’s available.”</p>
</blockquote>
</blockquote>
<p>Wrapping up, I hope you found this dive as intriguing! If your curiosity is still piqued,
consider tackling these additional equivalences:</p>
<p>I’ve put a <a href="https://www.typescriptlang.org/play?#code/PTAEDMEMBsGcFNQAcBOB7JbYEsAu20A7UQUqIAoXATyUQBUUBXRAXlAcIGtC0B3QgbjJkQoXI0SoMWPAWKASogrVEAMRgJQrQvABu8FIOFgAItlgArdgGN8RUAEFQgCiJQAIUU1QAeRQAeOwBpXAD4NUDJQUAAfUABvUUgAcwAuUAAiaHhwXFT+UG0YJhSHAF8wiOi43ESU1JRsBIALbNz86ELXUGKDMnArG2IMrL8ggApW9rsAShTvP0CtXRQQmPDQFHhcBhRiSuq0wezA8cQusmKhXsJrWTX6pp8XUeOUl2mvXwW9QMfY1fXN7axeLJNJ1RqHPIFE6Cc49Po3eB4Bp6OauQIAYVGqzQKBmvgCwX82MIABlMrgUiNIEVJhoQuiiREiAAlO4U0AjABGL1pzHpRLe6N+fw2W2II1WTJQADoqgkNMxWOlyakyhF1QB+UBEMlZEY46XHWmS9UpFls-Uyo2rSYwoSGUDoogWK79eygQDkRK53Ig7IQACaon6sADaBJcAF1uiIAJIAWyQ0GwlkgbocAFoQm4qB540ggyFWFSaXTXAYRABRACODGwrXgV19oB8fO9OcQMfA4ALoRDeYLgX7LkCdiCUaEIgAcvAEqmbgBCOw+0CTtC4YahEYADxLrc++ntImU2BQsFwoFTuHgCfPuDQyHQ-oYlkQkBXM7nulESjhrpuUGwDJ-QAfS0BJgMva8kFwEZaRWVZLmuWxwBxHQUVHYt7Dgk1-jFCBUMWKlbVWUohAids0HAfD1kWVYRHVAA9DV7QiRC3X9NAGE5DJQJnYYRi7SkU2gaBOUgSwOEpaksNLfdeRCOSil+dVQBAE02JuHhIDwYCUJovRMKmFJ92UlS1lFQEtJ0vS0JQIjBBU2EVNwwEuxGKzcF0gi9GIiJznIpRKNADiuJ4sC6LARjmIiejsEQVd1wS4YgjI0AMnPaTCAYONOT0UIQu4+BeISEYOFLDgRgAVkmYjVnS0BuVALKcry1g3wAalAAAmO0JzAJ0UHWaxgs4wqmo-N04wYM8GokdBtGwf14H9URkQfNAEhQSA4zjbBCHlaBIH2hhEngMglssQ71ggeFbAKsK+Iw8AUiSpLRyCN47HLMAYyWwh8CoNLIB4d1WyXDTbEW-jpKmUyXOISBepEABlNA40QSw0bjWxJEo2BQD20ASQ25NfyQ4hrC3AtYNMtSAo8BKHFYN6ggMen4rXFxQiSx42dUgAqQWheFkXRbF0BfobAHKCJ4H8bFhXFZF4BUvohxnFUOBEBbEIlwiTHCBmxapbwShgMOnhgIARhSTtu1mAlNYQIIR0LUAQ1SmKwHV0AncQTN7BNEY7BxP35NARFcGROyQ5QP3AkWwJIE5WAthW1tk9TlB-UmIkTREDNdacX21DOlSiNLA4iMZUBxwi90vXoJhmzB1YDaNv7pfN4HgK622uz8ANUSb+AXfsN2Pfz73PVAEfQADvX1SpANw6O-0QwABgjPOVIL+ei8b8Qg8gcOQ0geYGBE7fVjrmKlfvh-H6fhWVbo5-FffWc3Qt+X34flWIj1xJMDbUVEo6IHgFuS6DAlorV2v6f0GR64+0XG3IgM1IHQNgcBeBiD4B4lRIzN2Jp7pFTAqVUsJoIgVTBE0KklCzLqgqlXE+kwqGgBqiaWqXsG6gEXPvEuWs0GG3PGBbuPBbYJkHoGAkRDAh+zdiMM+8w1x2AjOHbguA7D2WEH-PR+jH6vzvu-UARhEAAFkcSzkIAAcnxsAngv8DFiwAapMA85g7F1eC3EI-CvTzjcPrdB54lrYxQNY62-duxJQdt8IIY8-SBhZoEHm8SJ5Tz4Z45w3iA5+L4YEpeCVgKx28a2D2jCIgV1bEUkpIwWE1UCOwypnJw41JxC4EYtCYItLYYw6+jCRB5ICQIjxPtXjsKUZogkmjIzh2Du08Okdo7zJQMOJqqiVG4FeDXOu9dRkz28TrPhKCClHhxFpbOwUTzwHJpkhwXocm+JOcImaoSrFHS6rpHg-pJH5jekPcM8TAizEZikzm8TQirBGDUtepSUoqVIcVChrZ2HMPJPQlFFTQA0ItJyBhWKVxrmKbCpR58GrqKaRw3pZlOEqV8mqEQLhxIcAuStf01zbn8OcMM3JniHnUvbiE687zCCfM5N835PgQUbMJVsse-yZFxIhcwIOjMcQJThUHZR5L5LsKWQZSlaqUAaprowkYUyNGqOrpS81nNLVbK5Lndh9LAEvKFWE6xfcJYDwVQWMe0qtFgrlRPN54SPlfP9IEUNnrgLiv9BGN+zik3Jv5q-RN99QDVlrPWRsN0-y2AAGRsEILIJxBijFuPdAHLmRyuXeh4coc5kBLnsqGm6Tx1baQBxGHW8ZQSREQEIMBdgsgI2Sv7IC4FvhQXBGIeXSAXUWl0nYYi8hZVMUVLRXqN8G6sU4vBBKAl6oF2ciIpSiItKKmXrpXzRlzLWVXLbTcHtYyu0hA7VmAVwTB3DpLUQWNEqJZSIDZOoD+ZAVzvVFM4COJgJc13ce5dWL9V2XPesrRMGUBwdNRU21Wj7XaJPjhs1S7WycmI+qbhoBBU-pHf++AVYok+AnXEqdPgZ2PAnuAIddGh3gG+YEbjv7R1xoTbCe0QggA">TS playground</a>
Where you can find other common proofs in Logic.</p>
<p>Happy proving!</p></section><hr/><footer><div class="bio"><p>Written by<!-- --> <a href="https://twitter.com/YassineElouafi2"><strong>Yassine EL Ouafi</strong></a></p></div></footer></article><nav class="blog-post-nav"><ul style="display:flex;flex-wrap:wrap;justify-content:space-between;list-style:none;padding:0"><li><a rel="prev" href="/2021-06-26-algebraic-effects-trees/2021-06-26-algebraic-effects-trees/">← <!-- -->Algebraic Effects: from Algebra to Programs</a></li><li></li></ul></nav></main><footer></footer></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/2023-09-04-pat/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-d2a314c619ae9d8e67ff.js"],"app":["/app-be01091e8f6277f5b6f6.js"],"component---src-pages-404-js":["/component---src-pages-404-js-97593667e44e4660bc60.js"],"component---src-pages-index-js":["/component---src-pages-index-js-6725867a2b20a509cc57.js"],"component---src-pages-using-typescript-tsx":["/component---src-pages-using-typescript-tsx-ec89e82605e2a0c5e9c7.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js-664fa24895fa0bb62323.js"]};/*]]>*/</script><script src="/polyfill-d2a314c619ae9d8e67ff.js" nomodule=""></script><script src="/component---src-templates-blog-post-js-664fa24895fa0bb62323.js" async=""></script><script src="/commons-140fdb61bcb6fdaf6bd2.js" async=""></script><script src="/app-be01091e8f6277f5b6f6.js" async=""></script><script src="/framework-c4b9952841844d9091bc.js" async=""></script><script src="/webpack-runtime-787195f1393efa40968d.js" async=""></script></body></html>