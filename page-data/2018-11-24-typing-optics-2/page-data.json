{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018-11-24-typing-optics-2/","result":{"data":{"site":{"siteMetadata":{"title":"Abstract fun"}},"markdownRemark":{"id":"070657c7-bcfc-5c00-91e0-df6a0456bfcb","excerpt":"Last post I wrote about my first tentatives to add typings to my focused lens library. I explained the main issue was the lack of Higher Kinded Types in…","html":"<p><a href=\"/2018-11-23-typing-optics\">Last post</a> I wrote about my first tentatives to add typings to my <a href=\"https://github.com/yelouafi/focused\">focused lens library</a>. I explained the main issue was the lack of Higher Kinded Types in TypeScript which makes it uneasy to port abstractions from functional languages like Haskell.</p>\n<p>So with a hacky workaround, I ended up implementing basic type classes and Lenses, the main tradeoff being that the solution can only be used internally in the library, since we need to specify all type parameters at the call site. This is to allow the public API to be fully typed.</p>\n<p>So current status, we have <a href=\"https://www.typescriptlang.org/play/index.html#src=%2F%2F%20convenient%20shortcut%20for%20functions%20taking%201%20param%0D%0Atype%20Fn%3CA%2C%20B%3E%20%3D%20(x%3A%20A)%20%3D%3E%20B%3B%0D%0A%0D%0Ainterface%20Functor%3CA%2C%20B%2C%20FA%2C%20FB%3E%20%7B%0D%0A%20%20map(f%3A%20Fn%3CA%2C%20B%3E%2C%20x%3A%20FA)%3A%20FB%3B%0D%0A%7D%0D%0A%0D%0A%2F%2F%20I&#x27;m%20switching%20to%20an%20interface%20definition%20for%20better%20DX%0D%0Ainterface%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20%24applyOptic%3A%20(%3CFB%2C%20FT%3E(F%3A%20Functor%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%20f%3A%20Fn%3CA%2C%20FB%3E%2C%20s%3A%20S)%20%3D%3E%20FT)%3B%0D%0A%7D%0D%0A%0D%0A%2F%2F%20Monomorphic%20version%0D%0Atype%20SimpleLens%3CS%2C%20A%3E%20%3D%20Lens%3CS%2C%20S%2C%20A%2C%20A%3E%3B%0D%0A%0D%0A%2F%2F%20This%20should%20work%20polymorhically%20for%20any%20Functor%0D%0Aconst%20Identity%20%3D%20%7B%0D%0A%20%20map(f%2C%20x)%20%7B%0D%0A%20%20%20%20return%20f(x)%3B%0D%0A%20%20%7D%0D%0A%7D%3B%0D%0A%0D%0A%2F%2F%20Lens%20composition%0D%0Afunction%20compose%3CS%2C%20T%2C%20A%2C%20B%2C%20X%2C%20Y%3E(%0D%0A%20%20parent%3A%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%2C%0D%0A%20%20child%3A%20Lens%3CA%2C%20B%2C%20X%2C%20Y%3E%0D%0A)%3A%20Lens%3CS%2C%20T%2C%20X%2C%20Y%3E%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic(F%2C%20f%2C%20s)%20%7B%0D%0A%20%20%20%20%20%20return%20parent.%24applyOptic(%0D%0A%20%20%20%20%20%20%20%20F%20as%20any%2C%0D%0A%20%20%20%20%20%20%20%20a%20%3D%3E%20child.%24applyOptic(F%20as%20any%2C%20f%2C%20a)%2C%0D%0A%20%20%20%20%20%20%20%20s%0D%0A%20%20%20%20%20%20)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20lens%3CS%2C%20T%2C%20A%2C%20B%3E(%0D%0A%20%20getter%3A%20Fn%3CS%2C%20A%3E%2C%0D%0A%20%20setter%3A%20(b%3A%20B%2C%20s%3A%20S)%20%3D%3E%20T%0D%0A)%3A%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic%3CFB%2C%20FT%3E(F%3A%20Functor%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%20f%3A%20Fn%3CA%2C%20FB%3E%2C%20s%3A%20S)%3A%20FT%20%7B%0D%0A%20%20%20%20%20%20const%20a%20%3D%20getter(s)%3B%0D%0A%20%20%20%20%20%20const%20fb%20%3D%20f(a)%3B%0D%0A%20%20%20%20%20%20return%20F.map(b%20%3D%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20setter(b%2C%20s)%3B%0D%0A%20%20%20%20%20%20%7D%2C%20fb)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20over%3CS%2C%20T%2C%20A%2C%20B%3E(l%3A%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%2C%20f%3A%20Fn%3CA%2C%20B%3E%2C%20s%3A%20S)%3A%20T%20%7B%0D%0A%20%20return%20l.%24applyOptic(Identity%20as%20Functor%3CB%2C%20T%2C%20B%2C%20T%3E%2C%20f%2C%20s)%3B%0D%0A%7D%0D%0A%0D%0Afunction%20prop%3CS%3E()%20%7B%0D%0A%20%20return%20%3CK%20extends%20keyof%20S%3E(k%3A%20K)%3A%20SimpleLens%3CS%2C%20S%5BK%5D%3E%20%3D%3E%20%7B%0D%0A%20%20%20%20return%20lens(s%20%3D%3E%20s%5Bk%5D%2C%20(a%2C%20s)%20%3D%3E%20Object.assign(%7B%7D%2C%20s%2C%20%7B%20%5Bk%5D%3A%20a%20%7D))%3B%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Atype%20Address%20%3D%20%7B%0D%0A%20%20street%3A%20string%3B%0D%0A%20%20num%3A%20number%3B%0D%0A%7D%3B%0D%0A%0D%0Atype%20Person%20%3D%20%7B%0D%0A%20%20name%3A%20string%3B%0D%0A%20%20address%3A%20Address%3B%0D%0A%20%20addresses%3A%20Address%5B%5D%3B%0D%0A%7D%3B%0D%0A%0D%0Aconst%20address%20%3D%20prop%3CPerson%3E()(%22address%22)%3B%0D%0Aconst%20addresses%20%3D%20prop%3CPerson%3E()(%22addresses%22)%3B%0D%0Aconst%20num%20%3D%20prop%3CAddress%3E()(%22num%22)%3B%0D%0A%0D%0Aconst%20l%20%3D%20compose(%0D%0A%20%20address%2C%0D%0A%20%20num%0D%0A)%3B%0D%0A\">working definitions</a> for</p>\n<ul>\n<li>basic typeclasses (Functor for now)</li>\n<li>Lenses</li>\n<li>Lens Composition</li>\n<li>implementation of <code class=\"language-text\">over</code></li>\n</ul>\n<p>Next step, we’ll add <code class=\"language-text\">Traversal</code>. It’s the same definition as <code class=\"language-text\">Lens</code> but requires an <code class=\"language-text\">Applicative</code> instead of just a <code class=\"language-text\">Functor</code> (since a Traversal needs to operate on many values). So we need to add a definition for Applicatives as well</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Applicative<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FA</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FB</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Functor<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FA</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FB</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  pure<span class=\"token operator\">:</span> Fn<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FA</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">combine</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> Fn<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> fas<span class=\"token operator\">:</span> <span class=\"token constant\">FA</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">FB</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If you’re familiar with the usual Applicative definition from Haskell, the definition of <code class=\"language-text\">combine</code> may be a little surprising, i,e, I ‘should’ define something like</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">apply<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token constant\">F</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token constant\">F</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span>`</code></pre></div>\n<p>There are 2 reasons for the above choice:</p>\n<ol>\n<li><code class=\"language-text\">apply</code> definition makes more sense when used with languages supporting automatic currying: in Haskell, <code class=\"language-text\">&lt;*&gt;</code> (which is the operator alias for <code class=\"language-text\">apply</code>) can be used conveniently on a function <code class=\"language-text\">f</code> taking many arguments (<code class=\"language-text\">a, b, c..</code>): (e.g. <code class=\"language-text\">f &lt;$&gt; fa &lt;*&gt; fb &lt;*&gt; fc ..</code>). In typical JavaScript (and TypeScript) we don’t use currying much often.</li>\n<li>More important, all the interfaces are mainly to be used internally by <code class=\"language-text\">focused</code> to define the public API. The recurrent use case for using Applicatives with Traversals is to operate on the values embedded inside a monomorphic container (i.e. containing many values of the same type like <code class=\"language-text\">Array</code>, <code class=\"language-text\">Set</code> …), so it makes more sense to adopt the <code class=\"language-text\">combine</code> definition rather than a polymorphic/curry-oriented version.</li>\n</ol>\n<p>The definition of a Traversal is</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Traversal<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  $applyOptic<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">FB</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FT</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n    <span class=\"token constant\">F</span><span class=\"token operator\">:</span> Applicative<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FB</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FT</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    f<span class=\"token operator\">:</span> Fn<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FB</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    s<span class=\"token operator\">:</span> <span class=\"token constant\">S</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">FT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The Applicative implementation for <code class=\"language-text\">Identity</code> is trivial</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> Identity <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n  <span class=\"token function-variable function\">pure</span><span class=\"token operator\">:</span> x <span class=\"token operator\">=></span> x<span class=\"token punctuation\">,</span>\n  <span class=\"token function\">combine</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> xs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>xs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Next step, we need to adjust the type definition of <code class=\"language-text\">compose</code> (we don’t have to touch the implementation, just instructs the compiler how to derive the right Optic).</p>\n<p>So here begins our second challenge. In Haskell, we don’t have to write anything special since the compiler can automatically infer the result type. Remember, in Haskell the type definitions for Lens and Traversal are</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Lens</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">forall</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">.</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">F</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Traversal</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">forall</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">.</span> <span class=\"token constant\">Applicative</span> <span class=\"token constant\">F</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span></code></pre></div>\n<p>If for example we compose a Lens with a Traversal, the compiler infers that the <code class=\"language-text\">f</code> type parameter for the resulting function must satisfy both the <code class=\"language-text\">Functor</code> and <code class=\"language-text\">Applicative</code> constraints, since <code class=\"language-text\">Applicative</code> is more specific than <code class=\"language-text\">Functor</code>, the constraint can be simplified to <code class=\"language-text\">Applicative</code>, which yields the same type definition as <code class=\"language-text\">Traversal</code>.</p>\n<p>Now with TypeScript, the first issue is that we can’t use simple function composition because:</p>\n<ul>\n<li>Our optic functions has 3 paramaters (the typeclass, the function and the state)</li>\n<li>Even if we redefine our functions with the idiomatic/curried style, we’d have to solve the Higher Kinded Type issue again. And even if we take that road (e.g. using the URI solution) I doubt we’d succeed in making TypeScript unify the type parameter constraints.</li>\n</ul>\n<p>Still, TypeScript offers an <em>adhoc</em> solution: function overloading. We can define multiple signatures for each combination of 2 optics. Normally, since we have [for now] 2 optics (Lens &#x26; Traversal) we’d have to write 4 (2*2) overloads. But in reality we ‘should’ only have 2 cases. Why? first let’s write down the definitions</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  parent<span class=\"token operator\">:</span> Lens<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  child<span class=\"token operator\">:</span> Lens<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Lens<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  parent<span class=\"token operator\">:</span> Traversal<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  child<span class=\"token operator\">:</span> Traversal<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Traversal<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Lens composition</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">$applyOptic</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">.</span><span class=\"token function\">$applyOptic</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">=></span> child<span class=\"token punctuation\">.</span><span class=\"token function\">$applyOptic</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now, here is the why: because every Lens is also a Traversal (the inverse is not necessarily true). Remember that the 2 interfaces differ only on the constraint imposed on the typeclass (the 1st) parameter:</p>\n<ul>\n<li>Lens is (equivalent to) a function which takes a Functor</li>\n<li>Traversal is (equivalent to) a function which takes an Applicative</li>\n</ul>\n<p>In other words, Lens’s function is more permissive (can take more values) than Traversal’s one. So it can be dropped on any context where a Traversal is expected. BTW, this is a general rule, it’s because functions are said to be <em>Contravariant</em> in their parameter types (you can replace a function with another taking more general argument => subtyping relation goes on the inverse direction of the enclosing function type). They are also <em>Covariant</em> in their results (you can replace a function with another returning a more specific result => subtyping relation goes on the same direction). There is a nice phrase in <a href=\"(%3Chttps://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\">Wikipedia</a>>) that summaises it</p>\n<blockquote>\n<p>be liberal in what you accept and conservative in what you produce</p>\n</blockquote>\n<p>But there’s still one (perhaps more) caveat. Contravariance isn’t enabled by default in TypeScript. Because for <a href=\"https://www.typescriptlang.org/docs/handbook/type-compatibility.html\">some reason</a> TS folks decided to make function types <em>bivariant</em> on their parameters (type compatibility works on both directions)</p>\n<blockquote>\n<p>When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns.</p>\n</blockquote>\n<p>Of course, there is a <code class=\"language-text\">strictFunctionTypes</code> option in TS which enables Contravariance in function parameters. But I’m not particularly comfortable with enforcing this on the library user. So we’d have to resort to some other workaround. This time we’ll simply add an optional field <code class=\"language-text\">$type</code> to each optic definition</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Lens<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">readonly</span> $<span class=\"token keyword\">type</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Lens\"</span> <span class=\"token operator\">&amp;</span> <span class=\"token string\">\"Traversal\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// $applyOptic:  ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Traversal<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">readonly</span> $<span class=\"token keyword\">type</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Traversal\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// $applyOptic: ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>It works, but to be honest, at the time of this writing, this is still kinda dog science for me. On one hand the fields are optional so we don’t have to alter the existing definitions (esp. <code class=\"language-text\">compose</code>), on the other hand, the compiler seems to infer correctly that Lens is more specific than Traversal without Contravarance enabled because of the presence of fields in the type definition.</p>\n<p>Only left (for today) is typing <code class=\"language-text\">over</code>. We’ll simply take the most generic optic which is <code class=\"language-text\">Traversal</code></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">over</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">:</span> Traversal<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> f<span class=\"token operator\">:</span> Fn<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> s<span class=\"token operator\">:</span> <span class=\"token constant\">S</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> l<span class=\"token punctuation\">.</span><span class=\"token generic-function\"><span class=\"token function\">$applyOptic</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>Identity<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I know, we’re getting more and more away from Haskell spirit but that’s inevitable. As I said, the main goal of this is to provide a working type definition for the public API. The library user could then uses Optics and operations like <code class=\"language-text\">over</code> or <code class=\"language-text\">view</code> in a typesafe way. If it means sacrificing the ‘internal elegance’ of the model, I’m ok with it.</p>\n<p>I believe it’s enough for today. Next challenge will be integrating Isomorphisms and Prisms</p>\n<h2>Links</h2>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/play/index.html#src=%2F%2F%20convenient%20shortcut%20for%20functions%20taking%201%20param%0D%0Atype%20Fn%3CA%2C%20B%3E%20%3D%20(x%3A%20A)%20%3D%3E%20B%3B%0D%0A%0D%0Ainterface%20Functor%3CA%2C%20B%2C%20FA%2C%20FB%3E%20%7B%0D%0A%20%20map(f%3A%20Fn%3CA%2C%20B%3E%2C%20x%3A%20FA)%3A%20FB%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Applicative%3CA%2C%20B%2C%20FA%2C%20FB%3E%20extends%20Functor%3CA%2C%20B%2C%20FA%2C%20FB%3E%20%7B%0D%0A%20%20pure%3A%20Fn%3CA%2C%20FA%3E%3B%0D%0A%20%20combine%3A%20(f%3A%20Fn%3CA%5B%5D%2C%20B%3E%2C%20fas%3A%20FA%5B%5D)%20%3D%3E%20FB%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20readonly%20%24type%3F%3A%20%22Lens%22%20%26%20%22Traversal%22%3B%0D%0A%20%20%24applyOptic%3A%20(%3CFB%2C%20FT%3E(F%3A%20Functor%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%20f%3A%20Fn%3CA%2C%20FB%3E%2C%20s%3A%20S)%20%3D%3E%20FT)%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Traversal%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20readonly%20%24type%3F%3A%20%22Traversal%22%3B%0D%0A%20%20%24applyOptic%3A%20(%3CFB%2C%20FT%3E(%0D%0A%20%20%20%20F%3A%20Applicative%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%0D%0A%20%20%20%20f%3A%20Fn%3CA%2C%20FB%3E%2C%0D%0A%20%20%20%20s%3A%20S%0D%0A%20%20)%20%3D%3E%20FT)%3B%0D%0A%7D%0D%0A%0D%0A%2F%2F%20Monomorphic%20version%0D%0Atype%20SimpleLens%3CS%2C%20A%3E%20%3D%20Lens%3CS%2C%20S%2C%20A%2C%20A%3E%3B%0D%0A%0D%0A%2F%2F%20This%20should%20work%20polymorhically%20for%20any%20Functor%0D%0Aconst%20Identity%20%3D%20%7B%0D%0A%20%20map(f%2C%20x)%20%7B%0D%0A%20%20%20%20return%20f(x)%3B%0D%0A%20%20%7D%2C%0D%0A%20%20pure%3A%20x%20%3D%3E%20x%2C%0D%0A%20%20combine(f%2C%20xs)%20%7B%0D%0A%20%20%20%20return%20f(xs)%3B%0D%0A%20%20%7D%0D%0A%7D%3B%0D%0A%0D%0Afunction%20compose%3CS%2C%20T%2C%20A%2C%20B%2C%20X%2C%20Y%3E(%0D%0A%20%20parent%3A%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%2C%0D%0A%20%20child%3A%20Lens%3CA%2C%20B%2C%20X%2C%20Y%3E%0D%0A)%3A%20Lens%3CS%2C%20T%2C%20X%2C%20Y%3E%3B%0D%0Afunction%20compose%3CS%2C%20T%2C%20A%2C%20B%2C%20X%2C%20Y%3E(%0D%0A%20%20parent%3A%20Traversal%3CS%2C%20T%2C%20A%2C%20B%3E%2C%0D%0A%20%20child%3A%20Traversal%3CA%2C%20B%2C%20X%2C%20Y%3E%0D%0A)%3A%20Traversal%3CS%2C%20T%2C%20X%2C%20Y%3E%3B%0D%0A%2F%2F%20Lens%20composition%0D%0Afunction%20compose(parent%2C%20child)%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic(F%2C%20f%2C%20s)%20%7B%0D%0A%20%20%20%20%20%20return%20parent.%24applyOptic(F%2C%20a%20%3D%3E%20child.%24applyOptic(F%2C%20f%2C%20a)%2C%20s)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%20as%20any%3B%0D%0A%7D%0D%0A%0D%0Afunction%20lens%3CS%2C%20T%2C%20A%2C%20B%3E(%0D%0A%20%20getter%3A%20Fn%3CS%2C%20A%3E%2C%0D%0A%20%20setter%3A%20(b%3A%20B%2C%20s%3A%20S)%20%3D%3E%20T%0D%0A)%3A%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic%3CFB%2C%20FT%3E(F%3A%20Functor%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%20f%3A%20Fn%3CA%2C%20FB%3E%2C%20s%3A%20S)%3A%20FT%20%7B%0D%0A%20%20%20%20%20%20const%20a%20%3D%20getter(s)%3B%0D%0A%20%20%20%20%20%20const%20fb%20%3D%20f(a)%3B%0D%0A%20%20%20%20%20%20return%20F.map(b%20%3D%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20setter(b%2C%20s)%3B%0D%0A%20%20%20%20%20%20%7D%2C%20fb)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20over%3CS%2C%20T%2C%20A%2C%20B%3E(l%3A%20Traversal%3CS%2C%20T%2C%20A%2C%20B%3E%2C%20f%3A%20Fn%3CA%2C%20B%3E%2C%20s%3A%20S)%3A%20T%20%7B%0D%0A%20%20return%20l.%24applyOptic%3CB%2C%20T%3E(Identity%2C%20f%2C%20s)%3B%0D%0A%7D%0D%0A%0D%0Afunction%20prop%3CS%3E()%20%7B%0D%0A%20%20return%20%3CK%20extends%20keyof%20S%3E(k%3A%20K)%3A%20SimpleLens%3CS%2C%20S%5BK%5D%3E%20%3D%3E%20%7B%0D%0A%20%20%20%20return%20lens(s%20%3D%3E%20s%5Bk%5D%2C%20(a%2C%20s)%20%3D%3E%20Object.assign(%7B%7D%2C%20s%2C%20%7B%20%5Bk%5D%3A%20a%20%7D))%3B%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20each%3CS%3E()%3A%20Traversal%3CS%5B%5D%2C%20S%5B%5D%2C%20S%2C%20S%3E%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic(F%2C%20f%2C%20xs)%20%7B%0D%0A%20%20%20%20%20%20return%20F.combine(ys%20%3D%3E%20ys%2C%20xs.map(f))%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Atype%20Address%20%3D%20%7B%0D%0A%20%20street%3A%20string%3B%0D%0A%20%20num%3A%20number%3B%0D%0A%7D%3B%0D%0A%0D%0Atype%20Person%20%3D%20%7B%0D%0A%20%20name%3A%20string%3B%0D%0A%20%20address%3A%20Address%3B%0D%0A%20%20addresses%3A%20Address%5B%5D%3B%0D%0A%7D%3B%0D%0A%0D%0Aconst%20address%20%3D%20prop%3CPerson%3E()(%22address%22)%3B%0D%0Aconst%20addresses%20%3D%20prop%3CPerson%3E()(%22addresses%22)%3B%0D%0Aconst%20num%20%3D%20prop%3CAddress%3E()(%22num%22)%3B%0D%0A%0D%0Aconst%20addressNum%20%3D%20compose(%0D%0A%20%20address%2C%0D%0A%20%20num%0D%0A)%3B%0D%0A%0D%0Aconst%20eachAddress%20%3D%20compose(%0D%0A%20%20addresses%2C%0D%0A%20%20each()%0D%0A)%3B%0D%0A%0D%0Aconst%20v%20%3D%20over(eachAddress%2C%20x%20%3D%3E%20x%2C%20%7B%7D%20as%20Person)%3B%0D%0A%0D%0Aconst%20v1%20%3D%20over(addressNum%2C%20x%20%3D%3E%20x%2C%20%7B%7D%20as%20Person)%3B%0D%0A\">TypeScript playground demo</a></li>\n</ul>","frontmatter":{"title":"Typing Optics (2): Traversals","date":"November 24, 2018","description":null}},"previous":{"fields":{"slug":"/2018-11-23-typing-optics/"},"frontmatter":{"title":"Typing Optics with TypeScript"}},"next":{"fields":{"slug":"/2018-11-27-typing-optics-3/"},"frontmatter":{"title":"Typing Optics (3): Isomorphisms and Prisms"}}},"pageContext":{"id":"070657c7-bcfc-5c00-91e0-df6a0456bfcb","previousPostId":"b0614ef9-ade9-537e-8842-663274d3e667","nextPostId":"87f5f226-da9c-52ca-94f5-fc3b8f552f82"}},"staticQueryHashes":["2841359383","3257411868"]}