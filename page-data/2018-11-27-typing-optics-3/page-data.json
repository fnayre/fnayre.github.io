{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018-11-27-typing-optics-3/","result":{"data":{"site":{"siteMetadata":{"title":"Abstract fun"}},"markdownRemark":{"id":"87f5f226-da9c-52ca-94f5-fc3b8f552f82","excerpt":"This is the 3rd post documenting my tentative to add typings to my focused lens library. So far, I’ve been able to add type definitions for base typeclasses…","html":"<p>This is the 3rd post documenting my tentative to add typings to my <a href=\"https://github.com/yelouafi/focused\">focused lens library</a>.</p>\n<p>So far, I’ve been able to add type definitions for</p>\n<ul>\n<li>base typeclasses/interfaces (Functor and Applicative)</li>\n<li>Lenses</li>\n<li>Traversals</li>\n<li>Lens &#x26; Traversal Composition</li>\n<li>type definition of <code class=\"language-text\">over</code></li>\n</ul>\n<p>In this post I’ll be tackling Isomorphisms and Prisms</p>\n<h3>Isomorphisms</h3>\n<p>If we look at the typical definition of Isos in Haskell</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Iso</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">forall</span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Profunctor</span> <span class=\"token hvariable\">p</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">s</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>There is <a href=\"https://artyom.me/lens-over-tea-4\">a story</a> behind this representation. You can read it in detail in the linked post (but it’s not required to follow the rest).</p>\n<p>To simplify, an Iso can be represented in 2 ways: functional &#x26; concrete . The concrete representation matches our intuition about Isos, a pair of inversible functions</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token keyword\">data</span> <span class=\"token constant\">CIso</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token constant\">CIso</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">s</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- or using the polymorphic version</span>\n<span class=\"token keyword\">data</span> <span class=\"token constant\">CIso</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">t</span> <span class=\"token operator\">=</span> <span class=\"token constant\">CIso</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">s</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The functional representation is similar to Lenses</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token keyword\">type</span> <span class=\"token constant\">FIso</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span></code></pre></div>\n<p>We need Isos <em>to be both above representations at once</em>. In Haskell we do this by creating a typeclass (something like an interface) that abstracts over both representations and instantiate (implement) the typeclass for each concrete representation. For Isos, the typeclass used is the Profunctor class. By making both functions and <code class=\"language-text\">CIso</code> instances of it, we can rely on Haskell type inference to choose the appropriate representation (for the interested <a href=\"https://repl.it/@yelouafi/function-Lenses\">here is an an implementation example</a>, look at the file Iso.hs).</p>\n<p>Now, in TypeScript, I don’t actually want to introduce Profunctors in the library for various reasons. But I can have both representation as part of the same interface.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Iso<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">readonly</span> $<span class=\"token keyword\">type</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Iso\"</span> <span class=\"token operator\">&amp;</span> <span class=\"token string\">\"Lens\"</span> <span class=\"token operator\">&amp;</span> <span class=\"token string\">\"Traversal\"</span><span class=\"token punctuation\">;</span>\n  $applyOptic<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">FB</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FT</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span><span class=\"token operator\">:</span> Functor<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FB</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FT</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> f<span class=\"token operator\">:</span> Fn<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FB</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> s<span class=\"token operator\">:</span> <span class=\"token constant\">S</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">FT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">from</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token constant\">S</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">A</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">to</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Each Iso is a also a Lens (and by extension a Traversal), since the functional implementation is the same as the Lens one.</p>\n<p>Now the trick is I can always construct the functional representation given the concrete representation</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">iso</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">from</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token constant\">S</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">to</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Iso<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">$applyOptic</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">,</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span>\n    to\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And I can inverse an Iso using the embedded pair of functions</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token keyword\">from</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>anIso<span class=\"token operator\">:</span> Iso<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Iso<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">S</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">iso</span><span class=\"token punctuation\">(</span>anIso<span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">,</span> anIso<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>But there is one caveat, if I compose an Iso with another Iso it’ll only give me the composed function <code class=\"language-text\">$applyOptic</code>, so the original <code class=\"language-text\">from</code> and <code class=\"language-text\">to</code> are gone. If I want to preserve the Isomorphism when composing 2 Isos, I’ll have to modify the <code class=\"language-text\">compose</code> function to handle this special case. In fact, this what’s done <a href=\"https://github.com/yelouafi/focused/blob/master/src/operations.js#L63-L74\">in the actual implementation</a>.</p>\n<p>Since now we have 3 optic types, normally we’d have to write 9 overloads for <code class=\"language-text\">compose</code> but as we already saw in the previous post, we need only 3 overloads (since every Iso is a Lens and a Traversal).</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  parent<span class=\"token operator\">:</span> Iso<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  child<span class=\"token operator\">:</span> Iso<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Iso<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  parent<span class=\"token operator\">:</span> Lens<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  child<span class=\"token operator\">:</span> Lens<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Lens<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  parent<span class=\"token operator\">:</span> Traversal<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  child<span class=\"token operator\">:</span> Traversal<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Traversal<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>We don’t need to modify the definition of <code class=\"language-text\">over</code> since it takes the most general type (Traversal).</p>\n<h3>Prisms</h3>\n<p>The definition of Prisms follows the same path. The Haskell definition is</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Prism</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">forall</span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Choice</span> <span class=\"token hvariable\">p</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Applicative</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">s</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>It’s the same as Isos except we use <code class=\"language-text\">Choice</code> in place of <code class=\"language-text\">Profunctor</code>. <code class=\"language-text\">Choice</code> is also a Profunctor but extends it with additional functions to deal with Sum types like Either (you can read <a href=\"https://artyom.me/lens-over-tea-5\">the full story here</a>).</p>\n<p>The concrete representation for Prisms is</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token keyword\">data</span> <span class=\"token constant\">CPrism</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">CPrism</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">s</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- Polymorphic version</span>\n<span class=\"token keyword\">data</span> <span class=\"token constant\">CPrism</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">CPrism</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">s</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Again it’s the same as Iso except that instead of <code class=\"language-text\">s -&gt; a</code> in Isos, we have now a <code class=\"language-text\">s -&gt; Either t a</code> (while an Iso always succeeds in extracting an <code class=\"language-text\">a</code> from <code class=\"language-text\">s</code>, a Prism can fail in which case it returns an alternative <code class=\"language-text\">t</code> that short-circuits the function <code class=\"language-text\">b -&gt; t</code>).</p>\n<p>Since we need to preserve Prisms over composition, we’ll follow the similar trick we did with Isos.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Either<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Left\"</span><span class=\"token punctuation\">;</span> value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Right\"</span><span class=\"token punctuation\">;</span> value<span class=\"token operator\">:</span> <span class=\"token constant\">B</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Prism<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">readonly</span> $<span class=\"token keyword\">type</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Prism\"</span> <span class=\"token operator\">&amp;</span> <span class=\"token string\">\"Traversal\"</span><span class=\"token punctuation\">;</span>\n  $applyOptic<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">FB</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FT</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n    <span class=\"token constant\">F</span><span class=\"token operator\">:</span> Applicative<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FB</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FT</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    f<span class=\"token operator\">:</span> Fn<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">FB</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    s<span class=\"token operator\">:</span> <span class=\"token constant\">S</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">FT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">match</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token constant\">S</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Either<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">build</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice the function takes an Applicative and not a Functor, we’ll see why in a minute.</p>\n<p><code class=\"language-text\">prism</code> function is used to construct a functional representation from a concrete one</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">prism</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">match</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token constant\">S</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Either<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">build</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Prism<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">$applyOptic</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> eta <span class=\"token operator\">=</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>eta<span class=\"token punctuation\">.</span><span class=\"token keyword\">type</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"Left\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// here!!</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">.</span><span class=\"token function\">pure</span><span class=\"token punctuation\">(</span>eta<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>build<span class=\"token punctuation\">,</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>eta<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    match<span class=\"token punctuation\">,</span>\n    build\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">F.pure(eta.value)</code> explains why we need an Applicative. In case the <code class=\"language-text\">match</code> fails in extracting a value from <code class=\"language-text\">S</code>, we get a <code class=\"language-text\">T</code> (wrapped in <code class=\"language-text\">Either</code>), since we need to return an <code class=\"language-text\">F&lt;T&gt;</code> from <code class=\"language-text\">T</code>, the <code class=\"language-text\">pure</code> function from the Applicative interface allows us to wrap plain values into the Applicative context (In fact we don’t need the whole Applicative just the <code class=\"language-text\">pure</code> part, this restricted interface is sometimes called <code class=\"language-text\">Pointed</code>).</p>\n<p>As for <code class=\"language-text\">compose</code> we need to add only one overload, if you consulted the implementation of <code class=\"language-text\">compose</code> linked in the previous section, you’ve already seen that there is also a special case analysis for composing 2 prisms.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  parent<span class=\"token operator\">:</span> Prism<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  child<span class=\"token operator\">:</span> Prism<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Iso<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">X</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>So far, it seems we have typings for the 4 optics, Remaining:</p>\n<ul>\n<li>Add typing for accessor functions <code class=\"language-text\">view</code>, <code class=\"language-text\">preview</code> and co</li>\n<li>I’ll have to figre Something for Getters</li>\n<li>Proxies</li>\n</ul>\n<h2>Links</h2>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/play/index.html#src=%2F%2F%20convenient%20shortcut%20for%20functions%20taking%201%20param%0D%0Atype%20Fn%3CA%2C%20B%3E%20%3D%20(x%3A%20A)%20%3D%3E%20B%3B%0D%0A%0D%0Atype%20Either%3CA%2C%20B%3E%20%3D%20%7B%20type%3A%20%22Left%22%3B%20value%3A%20A%20%7D%20%7C%20%7B%20type%3A%20%22Right%22%3B%20value%3A%20B%20%7D%3B%0D%0A%0D%0Ainterface%20Functor%3CA%2C%20B%2C%20FA%2C%20FB%3E%20%7B%0D%0A%20%20map(f%3A%20Fn%3CA%2C%20B%3E%2C%20x%3A%20FA)%3A%20FB%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Applicative%3CA%2C%20B%2C%20FA%2C%20FB%3E%20extends%20Functor%3CA%2C%20B%2C%20FA%2C%20FB%3E%20%7B%0D%0A%20%20pure%3A%20Fn%3CB%2C%20FB%3E%3B%0D%0A%20%20combine%3A%20(f%3A%20Fn%3CA%5B%5D%2C%20B%3E%2C%20fas%3A%20FA%5B%5D)%20%3D%3E%20FB%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Iso%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20readonly%20%24type%3F%3A%20%22Iso%22%20%26%20%22Lens%22%20%26%20%22Traversal%22%3B%0D%0A%20%20%24applyOptic%3A%20(%3CFB%2C%20FT%3E(F%3A%20Functor%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%20f%3A%20Fn%3CA%2C%20FB%3E%2C%20s%3A%20S)%20%3D%3E%20FT)%3B%0D%0A%20%20from%3A%20(s%3A%20S)%20%3D%3E%20A%3B%0D%0A%20%20to%3A%20(b%3A%20B)%20%3D%3E%20T%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Prism%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20readonly%20%24type%3F%3A%20%22Prism%22%20%26%20%22Traversal%22%3B%0D%0A%20%20%24applyOptic%3A%20(%3CFB%2C%20FT%3E(%0D%0A%20%20%20%20F%3A%20Applicative%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%0D%0A%20%20%20%20f%3A%20Fn%3CA%2C%20FB%3E%2C%0D%0A%20%20%20%20s%3A%20S%0D%0A%20%20)%20%3D%3E%20FT)%3B%0D%0A%20%20match%3A%20(s%3A%20S)%20%3D%3E%20Either%3CT%2C%20A%3E%3B%0D%0A%20%20build%3A%20(b%3A%20B)%20%3D%3E%20T%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20readonly%20%24type%3F%3A%20%22Lens%22%20%26%20%22Traversal%22%3B%0D%0A%20%20%24applyOptic%3A%20(%3CFB%2C%20FT%3E(F%3A%20Functor%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%20f%3A%20Fn%3CA%2C%20FB%3E%2C%20s%3A%20S)%20%3D%3E%20FT)%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Traversal%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20readonly%20%24type%3F%3A%20%22Traversal%22%3B%0D%0A%20%20%24applyOptic%3A%20(%3CFB%2C%20FT%3E(%0D%0A%20%20%20%20F%3A%20Applicative%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%0D%0A%20%20%20%20f%3A%20Fn%3CA%2C%20FB%3E%2C%0D%0A%20%20%20%20s%3A%20S%0D%0A%20%20)%20%3D%3E%20FT)%3B%0D%0A%7D%0D%0A%0D%0A%2F%2F%20Monomorphic%20version%0D%0Atype%20SimpleIso%3CS%2C%20A%3E%20%3D%20Iso%3CS%2C%20S%2C%20A%2C%20A%3E%3B%0D%0Atype%20SimplePrism%3CS%2C%20A%3E%20%3D%20Prism%3CS%2C%20S%2C%20A%2C%20A%3E%3B%0D%0Atype%20SimpleLens%3CS%2C%20A%3E%20%3D%20Lens%3CS%2C%20S%2C%20A%2C%20A%3E%3B%0D%0Atype%20SimpleTraversal%3CS%2C%20A%3E%20%3D%20Traversal%3CS%2C%20S%2C%20A%2C%20A%3E%3B%0D%0A%0D%0A%2F%2F%20This%20should%20work%20polymorhically%20for%20any%20Functor%0D%0Aconst%20Identity%20%3D%20%7B%0D%0A%20%20map(f%2C%20x)%20%7B%0D%0A%20%20%20%20return%20f(x)%3B%0D%0A%20%20%7D%2C%0D%0A%20%20pure%3A%20x%20%3D%3E%20x%2C%0D%0A%20%20combine(f%2C%20xs)%20%7B%0D%0A%20%20%20%20return%20f(xs)%3B%0D%0A%20%20%7D%0D%0A%7D%3B%0D%0A%0D%0Afunction%20compose%3CS%2C%20T%2C%20A%2C%20B%2C%20X%2C%20Y%3E(%0D%0A%20%20parent%3A%20Iso%3CS%2C%20T%2C%20A%2C%20B%3E%2C%0D%0A%20%20child%3A%20Iso%3CA%2C%20B%2C%20X%2C%20Y%3E%0D%0A)%3A%20Iso%3CS%2C%20T%2C%20X%2C%20Y%3E%3B%0D%0Afunction%20compose%3CS%2C%20T%2C%20A%2C%20B%2C%20X%2C%20Y%3E(%0D%0A%20%20parent%3A%20Prism%3CS%2C%20T%2C%20A%2C%20B%3E%2C%0D%0A%20%20child%3A%20Prism%3CA%2C%20B%2C%20X%2C%20Y%3E%0D%0A)%3A%20Prism%3CS%2C%20T%2C%20X%2C%20Y%3E%3B%0D%0A%0D%0Afunction%20compose%3CS%2C%20T%2C%20A%2C%20B%2C%20X%2C%20Y%3E(%0D%0A%20%20parent%3A%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%2C%0D%0A%20%20child%3A%20Lens%3CA%2C%20B%2C%20X%2C%20Y%3E%0D%0A)%3A%20Lens%3CS%2C%20T%2C%20X%2C%20Y%3E%3B%0D%0Afunction%20compose%3CS%2C%20T%2C%20A%2C%20B%2C%20X%2C%20Y%3E(%0D%0A%20%20parent%3A%20Traversal%3CS%2C%20T%2C%20A%2C%20B%3E%2C%0D%0A%20%20child%3A%20Traversal%3CA%2C%20B%2C%20X%2C%20Y%3E%0D%0A)%3A%20Traversal%3CS%2C%20T%2C%20X%2C%20Y%3E%3B%0D%0A%2F%2F%20Lens%20composition%0D%0Afunction%20compose(parent%2C%20child)%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic(F%2C%20f%2C%20s)%20%7B%0D%0A%20%20%20%20%20%20return%20parent.%24applyOptic(F%2C%20a%20%3D%3E%20child.%24applyOptic(F%2C%20f%2C%20a)%2C%20s)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%20as%20any%3B%0D%0A%7D%0D%0A%0D%0Afunction%20lens%3CS%2C%20T%2C%20A%2C%20B%3E(%0D%0A%20%20getter%3A%20Fn%3CS%2C%20A%3E%2C%0D%0A%20%20setter%3A%20(b%3A%20B%2C%20s%3A%20S)%20%3D%3E%20T%0D%0A)%3A%20Lens%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic%3CFB%2C%20FT%3E(F%3A%20Functor%3CB%2C%20T%2C%20FB%2C%20FT%3E%2C%20f%3A%20Fn%3CA%2C%20FB%3E%2C%20s%3A%20S)%3A%20FT%20%7B%0D%0A%20%20%20%20%20%20const%20a%20%3D%20getter(s)%3B%0D%0A%20%20%20%20%20%20const%20fb%20%3D%20f(a)%3B%0D%0A%20%20%20%20%20%20return%20F.map(b%20%3D%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20setter(b%2C%20s)%3B%0D%0A%20%20%20%20%20%20%7D%2C%20fb)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20over%3CS%2C%20T%2C%20A%2C%20B%3E(l%3A%20Traversal%3CS%2C%20T%2C%20A%2C%20B%3E%2C%20f%3A%20Fn%3CA%2C%20B%3E%2C%20s%3A%20S)%3A%20T%20%7B%0D%0A%20%20return%20l.%24applyOptic%3CB%2C%20T%3E(Identity%2C%20f%2C%20s)%3B%0D%0A%7D%0D%0A%0D%0Afunction%20iso%3CS%2C%20T%2C%20A%2C%20B%3E(from%3A%20(s%3A%20S)%20%3D%3E%20A%2C%20to%3A%20(b%3A%20B)%20%3D%3E%20T)%3A%20Iso%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic(F%2C%20f%2C%20s)%20%7B%0D%0A%20%20%20%20%20%20return%20F.map(to%2C%20f(from(s)))%3B%0D%0A%20%20%20%20%7D%2C%0D%0A%20%20%20%20from%2C%0D%0A%20%20%20%20to%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20prism%3CS%2C%20T%2C%20A%2C%20B%3E(%0D%0A%20%20match%3A%20(s%3A%20S)%20%3D%3E%20Either%3CT%2C%20A%3E%2C%0D%0A%20%20build%3A%20(b%3A%20B)%20%3D%3E%20T%0D%0A)%3A%20Prism%3CS%2C%20T%2C%20A%2C%20B%3E%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic(F%2C%20f%2C%20s)%20%7B%0D%0A%20%20%20%20%20%20const%20eta%20%3D%20match(s)%3B%0D%0A%20%20%20%20%20%20if%20(eta.type%20%3D%3D%3D%20%22Left%22)%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20F.pure(eta.value)%3B%0D%0A%20%20%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20F.map(build%2C%20f(eta.value))%3B%0D%0A%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%2C%0D%0A%20%20%20%20match%2C%0D%0A%20%20%20%20build%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20from%3CS%2C%20T%2C%20A%2C%20B%3E(anIso%3A%20Iso%3CS%2C%20T%2C%20A%2C%20B%3E)%3A%20Iso%3CB%2C%20A%2C%20T%2C%20S%3E%20%7B%0D%0A%20%20return%20iso(anIso.to%2C%20anIso.from)%3B%0D%0A%7D%0D%0A%0D%0Afunction%20prop%3CS%3E()%20%7B%0D%0A%20%20return%20%3CK%20extends%20keyof%20S%3E(k%3A%20K)%3A%20SimpleLens%3CS%2C%20S%5BK%5D%3E%20%3D%3E%20%7B%0D%0A%20%20%20%20return%20lens(s%20%3D%3E%20s%5Bk%5D%2C%20(a%2C%20s)%20%3D%3E%20Object.assign(%7B%7D%2C%20s%2C%20%7B%20%5Bk%5D%3A%20a%20%7D))%3B%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20each%3CS%3E()%3A%20Traversal%3CS%5B%5D%2C%20S%5B%5D%2C%20S%2C%20S%3E%20%7B%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20%24applyOptic(F%2C%20f%2C%20xs)%20%7B%0D%0A%20%20%20%20%20%20return%20F.combine(ys%20%3D%3E%20ys%2C%20xs.map(f))%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Aconst%20idIso%3A%20SimpleIso%3Cnumber%2C%20number%3E%20%3D%20iso(%0D%0A%20%20s%20%3D%3E%20s%2C%0D%0A%20%20s%20%3D%3E%20s%0D%0A)%0D%0A%0D%0Aconst%20maybNum%3A%20SimplePrism%3Cstring%2C%20number%3E%20%3D%20prism(%0D%0A%20%20function%20match(s%3A%20string)%3A%20Either%3Cstring%2C%20number%3E%20%7B%0D%0A%20%20%20%20if%20(isNaN(%2Bs))%20%7B%0D%0A%20%20%20%20%20%20return%20%7B%20type%3A%20%22Left%22%2C%20value%3A%20s%20%7D%3B%0D%0A%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20return%20%7B%20type%3A%20%22Right%22%2C%20value%3A%20%2Bs%20%7D%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%2C%0D%0A%20%20n%20%3D%3E%20String(n)%0D%0A)%3B%0D%0A%0D%0Atype%20Address%20%3D%20%7B%0D%0A%20%20street%3A%20string%3B%0D%0A%7D%3B%0D%0A%0D%0A%0D%0A%2F%2F%20Iso%20%2B%20Iso%20%3D%20Iso%0D%0Aconst%20trivialIso%20%3D%20compose(idIso%2C%20from(idIso))%20%0D%0A%0D%0A%2F%2F%20Prism%20%2B%20Lens%20%3D%20Traversal%0D%0Aconst%20streetNum%20%3D%20compose(%0D%0A%20%20prop%3CAddress%3E()(%22street%22)%2C%0D%0A%20%20maybNum%0D%0A)%3B%0D%0A%0D%0A\">TypeScript playground</a></li>\n</ul>","frontmatter":{"title":"Typing Optics (3): Isomorphisms and Prisms","date":"November 24, 2018","description":null}},"previous":{"fields":{"slug":"/2018-11-24-typing-optics-2/"},"frontmatter":{"title":"Typing Optics (2): Traversals"}},"next":{"fields":{"slug":"/2018-11-29-typing-optics-4/"},"frontmatter":{"title":"Typing Optics (4): Getters and Const"}}},"pageContext":{"id":"87f5f226-da9c-52ca-94f5-fc3b8f552f82","previousPostId":"070657c7-bcfc-5c00-91e0-df6a0456bfcb","nextPostId":"504c34f5-67a2-5191-822d-ff90d35e8a84"}},"staticQueryHashes":["2841359383","3257411868"]}