{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018-12-15-csv-parser/","result":{"data":{"site":{"siteMetadata":{"title":"Abstract fun"}},"markdownRemark":{"id":"1a28ca1a-8089-53fa-b753-d17b94bb1857","excerpt":"Some time ago, I wrote a tutorial about parser combinators. The tutorial shows ho we can, with a few primitive parsers (e.g. for text and regular expressions…","html":"<p>Some time ago, I wrote a <a href=\"/2018-11-19-introduction-to-parser-combinators\">tutorial about parser combinators</a>. The tutorial shows ho we can, with a few primitive parsers (e.g. for text and regular expressions) and combinators, we can gradually compose simple parsers to build more complex parsers. Alongside the post, I also published a JavaScript library called <a href=\"https://github.com/yelouafi/pcomb\">pcomb</a> to play with the introduced concepts. The library features many parser combinators that can be used to compose complex parsers.</p>\n<p>In this post, I’d like to walk the interested reader through an example of using parser combinators. We’ll implement a parser for tabular <a href=\"https://en.wikipedia.org/wiki/Comma-separated_values\">CSV file format</a>.</p>\n<p>First, we need a precise definition for our language. Usually we should use a formal notation like EBNF to define the grammar, but here to keep things simple, and also because the language is not too complicated, we’ll just do with a textual definition.</p>\n<p>Quoting Wikipedia page:</p>\n<blockquote>\n<p>a comma-separated values (CSV) file is a delimited text file that uses a comma to separate values. A CSV file stores tabular data (numbers and text) in plain text. Each line of the file is a data record. Each record consists of one or more fields, separated by commas.</p>\n</blockquote>\n<p>So for our purpose, assuming we have a string containing the CSV file content</p>\n<ul>\n<li>A CSV is a collection of records separated by line breaks.</li>\n<li>A record is a collection of fields separated by commas.</li>\n</ul>\n<p>Let’s try to translate this into actual code.</p>\n<h2>First attempt</h2>\n<p>We begin by importing some basic parsers</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> text<span class=\"token punctuation\">,</span> regex<span class=\"token punctuation\">,</span> eof <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"pcomb\"</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">text</code> allows us to match (=parse) a given literal string</li>\n<li><code class=\"language-text\">regex</code> allows us to parse a string that matches a given regular expression</li>\n<li><code class=\"language-text\">eof</code> ensures that we’ve reached the <strong>e</strong>nd <strong>o</strong>f <strong>f</strong>ile (there are no more superfluous charachters on the input string).</li>\n</ul>\n<p>Next we define our most basic parsers.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> lineBreak <span class=\"token operator\">=</span> <span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> comma <span class=\"token operator\">=</span> <span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> field <span class=\"token operator\">=</span> <span class=\"token function\">regex</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\n,]*</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We may also call the above definitions <em>lexical scanners</em>. If you’ve consulted some other parser tutorials, you may have encountered the following description of a parsing workflow</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  | Lexical scanner | --&gt; | Parser |</code></pre></div>\n<p>We first run a lexical scanning phase on the input string, where we transform the sequence of raw input characters into a sequence of <em>tokens</em> (e.g. numbers, operators, simple variables). Then we feed this token sequence into a parsing phase that assembles them into more complex structures (e.g. arithmetic expressions).</p>\n<p>With parser combinators, we can follow a similar process, except that we’re using the same abstraction. Since everything is a parser, we’re just assembling basic parsers into more complex parsers.</p>\n<p>Note that, for each one of above parsers (or lexers if you want), the result of parsing an input string is a string representing the matched slice. For example, <code class=\"language-text\">field</code> will return a substring matching any character except <code class=\"language-text\">\\n</code> and <code class=\"language-text\">,</code>.</p>\n<p>Next, we define records, remember the definition was</p>\n<blockquote>\n<p>a collection of fields separated by commas</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> record <span class=\"token operator\">=</span> field<span class=\"token punctuation\">.</span><span class=\"token function\">sepBy</span><span class=\"token punctuation\">(</span>comma<span class=\"token punctuation\">)</span></code></pre></div>\n<p>The definition is rather self-descriptive. The <code class=\"language-text\">A.sepBy(SEP)</code> method transforms a parser for a thing <code class=\"language-text\">a</code> into a parser of a collection of zero or more things <code class=\"language-text\">a sep a sep a ...</code>. <code class=\"language-text\">SEP</code> can be an arbitrary parser (as long as it doesn’t <em>overlap</em> with the definition of <code class=\"language-text\">A</code>).</p>\n<p>More concretely, the result of parsing an input string with <code class=\"language-text\">record</code> will return an array of strings (or raise an error if the input string doesn’t match the expected format)</p>\n<p>Finally the definition of a parser for the whole CSV input was</p>\n<blockquote>\n<p>A CSV is a collection of records separated by line breaks</p>\n</blockquote>\n<p>Which translates to</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> csv <span class=\"token operator\">=</span> record<span class=\"token punctuation\">.</span><span class=\"token function\">sepBy</span><span class=\"token punctuation\">(</span>lineBreak<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">skip</span><span class=\"token punctuation\">(</span>eof<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">record.sepBy(lineBreak)</code> should be obvious by now. <code class=\"language-text\">skip(eof)</code> ensure that there are no more characters left on the input string.</p>\n<p>The full source code is given below</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> text<span class=\"token punctuation\">,</span> regex<span class=\"token punctuation\">,</span> eof <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"pcomb\"</span>\n\n<span class=\"token keyword\">const</span> lineBreak <span class=\"token operator\">=</span> <span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> comma <span class=\"token operator\">=</span> <span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> field <span class=\"token operator\">=</span> <span class=\"token function\">regex</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\n,]*</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> record <span class=\"token operator\">=</span> field<span class=\"token punctuation\">.</span><span class=\"token function\">sepBy</span><span class=\"token punctuation\">(</span>comma<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> csv <span class=\"token operator\">=</span> record<span class=\"token punctuation\">.</span><span class=\"token function\">sepBy</span><span class=\"token punctuation\">(</span>lineBreak<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">skip</span><span class=\"token punctuation\">(</span>eof<span class=\"token punctuation\">)</span></code></pre></div>\n<p>To run the parser on an input string we use the <code class=\"language-text\">parse</code> method. It either returns the parse result or raises an error. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">parser<span class=\"token punctuation\">,</span> source</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> parser<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>csv<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Id,Name\\n1,Yahya\\n2,Ayman\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// => [[\"Id\",\"Name\"],[\"1\",\"Yahya\"],[\"2\",\"Ayman\"]]</span></code></pre></div>\n<h2>Improving the parser</h2>\n<p>One caveat with the above parser appears when we try to parse an input like</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Year,Make,Model,Description,Price\n1997,Ford,E350,&quot;ac, abs, moon&quot;,3000.00</code></pre></div>\n<p>When parsing the above input we get</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">;</span><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">[</span><span class=\"token string\">\"Year\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Make\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Model\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Description\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Price\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span><span class=\"token string\">\"1997\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Ford\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"E350\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'\"ac'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" abs\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">' moon\"'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"3000.00\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Our header (first line) presupposes that each record should contain 5 fields, yet the parsed result for the second line contains 7 fields.</p>\n<p>The issue is that the 4th field of the second line contains commas (<code class=\"language-text\">,</code>) embedded within quotes (<code class=\"language-text\">&quot;&quot;</code>). It’s not exactly that the implementation of our parser was wrong, the real issue is our definition was not accurate enough to account for <em>quoted fields</em>, i.e. fields which use quotes to embed characters that would normally be interpreted as tokens (newlines or commas) in our defined language.</p>\n<p>So to ‘fix’ our language we must improve our description with a definition for field content</p>\n<ul>\n<li>A CSV is a collection of records separated by line breaks.</li>\n<li>A record is a collection of fields separated by commas.</li>\n<li>\n<p>A field is either</p>\n<ul>\n<li>a quoted string</li>\n<li>an unquoted string</li>\n</ul>\n</li>\n<li>A quoted string is a sequence of characters between quotes (<code class=\"language-text\">&quot;...&quot;</code>). Within the quotes a character <code class=\"language-text\">&quot;</code> must be prefixed by another <code class=\"language-text\">&quot;</code> (like <code class=\"language-text\">&quot;abc&quot;&quot;xyz&quot;</code>).</li>\n<li>An unquoted string is any string not starting with a quote <code class=\"language-text\">&quot;</code>, any character except <code class=\"language-text\">\\n</code> and <code class=\"language-text\">,</code> are allowed.</li>\n</ul>\n<p>Let’s translate this into code, first we need to update our imports</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> text<span class=\"token punctuation\">,</span> regex<span class=\"token punctuation\">,</span> oneOf<span class=\"token punctuation\">,</span> eof <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"pcomb\"</span></code></pre></div>\n<p>We add an import for the <code class=\"language-text\">oneOf</code> combinator, we’ll see the usage later.</p>\n<p>Next we update our ‘tokens’</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> lineBreak <span class=\"token operator\">=</span> <span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> comma <span class=\"token operator\">=</span> <span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// new tokens</span>\n<span class=\"token keyword\">const</span> unquoted <span class=\"token operator\">=</span> <span class=\"token function\">regex</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\n,]*</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> quoted <span class=\"token operator\">=</span> <span class=\"token function\">regex</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\"(?:[^\"]|\"\")*\"</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span> <span class=\"token operator\">=></span>\n  s<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\"\"</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'\"'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>We introduce 2 new tokens to reflect the new definition. <code class=\"language-text\">unquoted</code> is basically the same as the previous <code class=\"language-text\">field</code>. <code class=\"language-text\">quoted</code> introduces the new feature of embedding reserved tokens within quotes.</p>\n<p>We also add some post cleanup using the <code class=\"language-text\">map</code> method, <code class=\"language-text\">A.map(f)</code> method allows transforming the result of a parser <code class=\"language-text\">a</code> into result <code class=\"language-text\">f(a)</code> using the given function <code class=\"language-text\">f</code>. In our example, we remove the surrounding quotes and convert any eventual embedded double quotes back into single quotes.</p>\n<p>Next we update the definition of <code class=\"language-text\">field</code>, remember the new definition is now</p>\n<blockquote>\n<p>A field is either a quoted or unquoted string</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> field <span class=\"token operator\">=</span> <span class=\"token function\">oneOf</span><span class=\"token punctuation\">(</span>quoted<span class=\"token punctuation\">,</span> unquoted<span class=\"token punctuation\">)</span></code></pre></div>\n<p>The <code class=\"language-text\">oneOf(...ps)</code> combinator introduces a <em>choice</em> between 2 (or more) parsers. The resulting parser will match any of the given parsers (or fail if none matches).</p>\n<p>The rest of the definitions remain unchanged. The whole new implementation becomes</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> text<span class=\"token punctuation\">,</span> regex<span class=\"token punctuation\">,</span> oneOf<span class=\"token punctuation\">,</span> eof <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"pcomb\"</span>\n\n<span class=\"token keyword\">const</span> lineBerak <span class=\"token operator\">=</span> <span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> comma <span class=\"token operator\">=</span> <span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> unquoted <span class=\"token operator\">=</span> <span class=\"token function\">regex</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\n,]*</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> quoted <span class=\"token operator\">=</span> <span class=\"token function\">regex</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\"(?:[^\"]|\"\")*\"</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span> <span class=\"token operator\">=></span>\n  s<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\"\"</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'\"'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> field <span class=\"token operator\">=</span> <span class=\"token function\">oneOf</span><span class=\"token punctuation\">(</span>quoted<span class=\"token punctuation\">,</span> unquoted<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> record <span class=\"token operator\">=</span> field<span class=\"token punctuation\">.</span><span class=\"token function\">sepBy</span><span class=\"token punctuation\">(</span>comma<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> csv <span class=\"token operator\">=</span> record<span class=\"token punctuation\">.</span><span class=\"token function\">sepBy</span><span class=\"token punctuation\">(</span>lineBerak<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">skip</span><span class=\"token punctuation\">(</span>eof<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Using on the previous input</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>\n  csv<span class=\"token punctuation\">,</span>\n  <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Year,Make,Model,Description,Price\n1997,Ford,E350,\"ac, abs, moon\",3000.00</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We get the correct number of fields in the records.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">[\n  [&quot;Year&quot;,&quot;Make&quot;,&quot;Model&quot;,&quot;Description&quot;,&quot;Price&quot;],\n  [&quot;1997&quot;,&quot;Ford&quot;,&quot;E350&quot;,&quot;ac, abs, moon&quot;,&quot;3000.00&quot;]\n]</code></pre></div>\n<h2>Addendum: Enforcing more constraints</h2>\n<p>So far, we’ve seen how to enforce what could be (roughly) described as <em>syntactic constraints</em> with our parser definitions. Our parser could also be further improved to enforce some <em>semantic constraints</em>. For example, observe the following input</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Year,Make,Model,Description,Price\n1997,Ford,E350,&quot;ac, abs, moon&quot;,3000.00\n1999,Chevy,&quot;Venture &quot;&quot;Extended Edition&quot;&quot;&quot;,&quot;&quot;,4900.00\n1996,Jeep,Grand Cherokee,&quot;MUST SELL!, 5000.00,</code></pre></div>\n<p>The first line, the header, presupposes that each record in the CSV table should contain 5 columns. But the last line mistakenly contains a trailing comma <code class=\"language-text\">,</code>. Parsing the above input will succeed, but as a result we get a table where all records do not contain the same number of columns.</p>\n<p>We could enforce this kind of constraints by running a post-parse traversal on the parse result to ensure that the number of fields is consistent in the resulting table. But this looks like a sub-optimal solution, for example if we’re parsing a huge CSV file, and the above kind of error is located in one of the first lines, we don’t need to continue parsing the rest of the input, we can stop parsing immediately at the wrong line.</p>\n<p>A more optimal solution would be detecting those semantic errors as early as possible during parsing. The solution involves usually maintaining some user defined state during parsing and placing appropriate <em>guards</em> at specific parse steps (guards usually test a parse result against some actual user defined state).</p>\n<p>Since I intend to keep this a short tutorial, I’ll leave it here. And (maybe :)) I’ll write another post with a more detailed walk through on how to enforce semantic constraints.</p>\n<h2>Links</h2>\n<ul>\n<li>A <a href=\"https://codesandbox.io/s/jj91jjoy73\">codesanbox demo</a> featuring a demo of the CSV and many other example parsers</li>\n</ul>","frontmatter":{"title":"Write a CSV Parser","date":"December 15, 2018","description":null}},"previous":{"fields":{"slug":"/2018-12-02-typing-optics-5/"},"frontmatter":{"title":"Typing Optics (5): Lens Proxies"}},"next":{"fields":{"slug":"/2020-09-18-continuation-category/2020-09-18-continuation-category/"},"frontmatter":{"title":"The Category of continuations"}}},"pageContext":{"id":"1a28ca1a-8089-53fa-b753-d17b94bb1857","previousPostId":"6672d802-742c-5a3b-852a-c6df5b3eb597","nextPostId":"304e3b7a-f3f0-557a-b2da-fb9ff68e8792"}},"staticQueryHashes":["2841359383","3257411868"]}