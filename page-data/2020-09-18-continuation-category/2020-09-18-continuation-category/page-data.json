{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020-09-18-continuation-category/2020-09-18-continuation-category/","result":{"data":{"site":{"siteMetadata":{"title":"Abstract fun"}},"markdownRemark":{"id":"304e3b7a-f3f0-557a-b2da-fb9ff68e8792","excerpt":"Take a simple FP language without polymorphism, just monomorphic types, functions and products. It’s well known that this language can be modeled as a category…","html":"<p>Take a simple FP language without polymorphism, just monomorphic types, functions and products. It’s well known that this language can be modeled as a <a href=\"https://en.wikipedia.org/wiki/Category_(mathematics)\">category</a> where objects are types and morphisms are functions. Now for every category, we can obtain a dual category “for free” by taking the same objects and flipping morphisms around (i.e. a morphism <code class=\"language-text\">a -&gt; b</code> in the original categroy becomes <code class=\"language-text\">b -&gt; a</code> in its dual). Composition in the dual category also runs backward.</p>\n<p>I was always wondering: what’s the dual of the above ‘FP category’ ? Is there an intuitive way to reason about it ?</p>\n<p>In the dual category functions will be flipped around, obviously they’ll no longer be good pure functions (If, in the original function, 2 different values from the source type were mapped to a unique value in the target type, then by flipping the arrow we’ll be mapping a unique value to 2 distinct values). I don’t know much what to think of the new arrows (possibly special types of relations). Is there a simple and familiar way to reason about the dual category ?</p>\n<p>Some recent reading on continuations gave me an idea (it’s a lot handwavy but this is the best I can do). In the so called FP category the <code class=\"language-text\">void</code> type (i.e. with no values) is the initial object : there’s a unique function from it to every other type. Now, Here’s a trick: in the dual category <code class=\"language-text\">void</code> becomes the final object.</p>\n<p>The first thing we gonna need is to set our dual category in a more familiar setting. We can try to find a faithful representation of the dual category in terms of another category: it’s a bit like when you’re trying to understand what’s been said in a foreign language, you can just translate it to a more familiar language.</p>\n<p>In a our case we’ll try to crack our mysterious dual catgeory by exploiting the special role of the terminal object <code class=\"language-text\">void</code>, namely, the fact that now there’s a unique morphism from any object to it.</p>\n<p>Each object in the dual category will be represented by its unique morphism to <code class=\"language-text\">void</code>, so for each type <code class=\"language-text\">a</code> we’ll get a morphism <code class=\"language-text\">a -&gt; void</code>. Note those morphisms are <em>functions-like</em> : since <code class=\"language-text\">void</code> is uninhabited, we dont risk to map a value from <code class=\"language-text\">a</code> to 2 or more values in <code class=\"language-text\">void</code> (in fact, since <code class=\"language-text\">void</code> is empty, we can never <em>return</em> from a continuation).</p>\n<p>All morphisms <code class=\"language-text\">a -&gt; b</code> in the dual category become of the form <code class=\"language-text\">(a -&gt; void) -&gt; (b -&gt; void)</code> in our representation, by the very definition of a category, <code class=\"language-text\">a -&gt; b</code> compose with <code class=\"language-text\">b -&gt; void</code> to give the unique <code class=\"language-text\">a -&gt; void</code>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 302px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/634e9b9f4e8fbbf1cb3d47806c2f754c/5f1d2/slice-cat.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.92405063291139%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA3ElEQVQoz5WS646EIAyFff/H2808wGziDyMXa6WwlMtm7cQ46MSZ7weBYw+UI12ttZQiY0OMv5zSUd8sXX3NMAwp5aMuzn8zxzhNwMyIuDwDAI3inFNKEdFkjSPfic05572nK7z3uOKJYuRH2/M8A0B9g2VZtNaPtrc7aK2ttafJbTkhojGmDUwW08o+kv1XSeEpsKYru7Kv2Jyy756TX2WMaeoAQLq9MMs54zgqpUTRWvd9fxre+SNJKYUQZB5CYOYPzLXWnPjnfv/6vhHRMcILcymFiBAx5/yq5g/Lwf2lkPC4qgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Composition in slice category\"\n        title=\"Composition in slice category\"\n        src=\"/static/634e9b9f4e8fbbf1cb3d47806c2f754c/5f1d2/slice-cat.png\"\n        srcset=\"/static/634e9b9f4e8fbbf1cb3d47806c2f754c/c26ae/slice-cat.png 158w,\n/static/634e9b9f4e8fbbf1cb3d47806c2f754c/5f1d2/slice-cat.png 302w\"\n        sizes=\"(max-width: 302px) 100vw, 302px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>To ensure that the dual category is fully and faithfully represented, we need also to check that composition is preserved; In our case this is immediate since we reuse the same morphisms of the dual category in our representation.</p>\n<p>Now, observe that in a language with control operators (like Scheme’s <code class=\"language-text\">call/cc</code>), <code class=\"language-text\">a -&gt; void</code> looks quite like the type of a continuation consuming a type <code class=\"language-text\">a</code>: objects in the FP category (seen as value types) could thus be seen in the dual category as continuations!</p>\n<p>What about the meaning of morphisms ? they look like functions of the type</p>\n<p><code class=\"language-text\">(a -&gt; void) -&gt; (b -&gt; void)</code></p>\n<p>flip around the order of the 2 first parameters</p>\n<p><code class=\"language-text\">(b -&gt; ((a -&gt; void) -&gt; void))</code></p>\n<p>But <code class=\"language-text\">(a -&gt; void) -&gt; void)</code> is none but the notorious Continuation monad (<code class=\"language-text\">Cont void a</code>) and <code class=\"language-text\">b -&gt; Cont void a</code> is its corresponding kleisli arrow.</p>\n<p><em>Roughly speaking, a kleisli arrow for a monad m is the function <code class=\"language-text\">a -&gt; m b</code> which is a sort of special function from a to b but with some side effects represented by the monad m. Composition of this arrows is defined via the bind/chain/sequencing operation specific to the monad m.</em></p>\n<p>In summary, in the dual category</p>\n<ul>\n<li>objects can be seen as continuations</li>\n<li>morphisms can be seen as continuation transformers, which are equivalent to kleisli arrows of the Continuation monad</li>\n<li>composition of morphisms is equivalent to kleisli composition (sequencing)</li>\n</ul>\n<p>More concretely, a function <code class=\"language-text\">a -&gt; b</code> in the FP category becomes a continuation transformer <code class=\"language-text\">((b -&gt; void) -&gt; (a -&gt; void))</code> in the dual category. Which is equivalent to the kleisli arrow <code class=\"language-text\">a -&gt; Cont void b</code> (i.e. the CPS version of <code class=\"language-text\">a -&gt; b</code>).</p>\n<p>Now you may alerady know that “Continuation is the mother of all monads” which means we can simulate any monad m within the Continuation monad. If you’ve doubts, you may convince yourself by consulting the following link</p>\n<ul>\n<li><a href=\"bit.ly/2RAB2bU\">The essence of functional programming (section 3.3 Monads and CPS)</a></li>\n<li><a href=\"bit.ly/3hCgBpm\">The Mother of all Monads</a></li>\n<li><a href=\"bit.ly/2GZUIUi\">The reasonable effectiveness of the continuation monad</a></li>\n</ul>\n<p>A reasonable objection: the real <code class=\"language-text\">Cont r a</code> relies on specializing <code class=\"language-text\">r</code> in order simulate other monads. A plausible answer is that <code class=\"language-text\">void</code> is a subtype of every other type (think of the type <code class=\"language-text\">forall r.r</code> or the error that can bubble up from within any expression).</p>\n<p>My intuition about continuations is that they represent “the complement of the story” for a program, which is its running process. Every evaluation step can be captured by a label (continuation) we can jump to later. And the fact that the Continuation monad can simulate any monad leads me to think that all side effects are about manipulating the control flow/environment of the running program (even algebraic effects &#x26; handlers are operationally about manipulating continuations).</p>\n<p>Could we thus conclude that [a way of thinking of] the dual category is: it models the running envionment of a program (which is <em>statically</em> modeled by the FP catgeory) where side effects take place ? Well, I can’t confirm since my reasonment is informal, but there are many artifacts that lead me to think so.</p>\n<p>Moreover, observe that any continuation can be embedded in the FP language as an ordinary function. We can’t construct a function to <code class=\"language-text\">void</code> in the FP category, but we can always map <code class=\"language-text\">void</code> to a non empty type. This way, the running environment can be captured back inside the FP category via a CPS transform. This is essentially how the Continuation monad works.</p>\n<p>I get this is a bit handwavy and lacks formality. It’s based on my still immature understanding of Category Theory. But if that makes sense, I beat there’s a better explanation using some higher order concepts, event better, there’s a formal paper somewhere about it.</p>\n<p>The idea originally came to me from Logic, <a href=\"https://en.wikipedia.org/wiki/Intuitionistic_logic\">Constructive logic</a> (where <code class=\"language-text\">not(not(a)) == a</code> doesn’t hold) is known to model FP languages like the Simply Typed Lambda Calculus. In contrast, <a href=\"https://en.wikipedia.org/wiki/Classical_logic\">Classical logic</a> (where <code class=\"language-text\">not(not(a)) == a</code> holds) corresponds to a language with first class continuations (labels &#x26; jumps).</p>\n<p>Computationally, the proposition <code class=\"language-text\">not(a)</code> correponds to the type <code class=\"language-text\">a -&gt; void</code> and <code class=\"language-text\">not(not(a)) == a</code> can be interpreted computationally as the ability to turn a type <code class=\"language-text\">a -&gt; (a -&gt; void)</code> into <code class=\"language-text\">a</code> via some control operator. We can then invoke the continuation <code class=\"language-text\">a -&gt; void</code> to provide a value of type <code class=\"language-text\">a</code> to some location in the program).</p>\n<p>In his famous paper <a href=\"bit.ly/3kn5mmz\">A Formulae-as-Types Notion of Control</a>, Timothy G. Griffin showed that embedding Classical into Constructive logic is computationally equivalent to a CPS translation of a program with labels &#x26; jumps into a language that explicitly represents continuations as functions. It seems to me (unless I messed up) that the above Category gymnastic describes the same idea: In a “classical language” you can acheive side effects by manipulating the environment of the running program and this environment is modeled by the dual FP category. But the envirnment can also be embedded back in the original category (pure FP language) via a CPS translation (which is equivalent to using monads in the FP language (?).</p>\n<p>So in one hand we have the static description of a pure FP program as an algebraic expression, while on the dual side we have the dynamic/operational description of the program as a series of evaluation steps.</p>\n<p>There’s also an equivalent formulation with sets: the dual of the category of Sets &#x26; functions is the category of boolean algebras. Boolean algebras is a denotation of classical logic (which translates to a language with continuations).</p>","frontmatter":{"title":"The Category of continuations","date":"September 18, 2020","description":null}},"previous":{"fields":{"slug":"/2018-12-15-csv-parser/"},"frontmatter":{"title":"Write a CSV Parser"}},"next":{"fields":{"slug":"/2021-01-20-react-callbacks/"},"frontmatter":{"title":"A simple rule for using callbacks in React"}}},"pageContext":{"id":"304e3b7a-f3f0-557a-b2da-fb9ff68e8792","previousPostId":"1a28ca1a-8089-53fa-b753-d17b94bb1857","nextPostId":"1796357a-dcc8-5856-b421-d675ed5ca357"}},"staticQueryHashes":["2841359383","3257411868"]}