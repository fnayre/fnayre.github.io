{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021-01-20-react-callbacks/","result":{"data":{"site":{"siteMetadata":{"title":"Abstract fun"}},"markdownRemark":{"id":"1796357a-dcc8-5856-b421-d675ed5ca357","excerpt":"In this post I assume you know React and the Hooks API. I also assume a basic knowledge about render and commit phases in Concurrent mode. Most of React hooks…","html":"<blockquote>\n<p>In this post I assume you know React and the Hooks API. I also assume a basic knowledge about render and commit phases in Concurrent mode.</p>\n</blockquote>\n<p>Most of React hooks complaints seem to revolve around having to manually manage hooks dependencies. Personally, I don’t find that problematic (The rules are pretty clear, and you can just follow the linter). I was, however, having difficulty wrapping my head around the <code class=\"language-text\">useCallback</code> hook. Yes, I know what it does and how it works, but I’m talking about having a simple mental model and how it fits into the greater picture inside a React application.</p>\n<p>Well, dependency management plays a role in the following story but not the way it’s often stated. I think the issue is not having to manage dependencies by ourselves, but the way reactivity in React plays with side effects.</p>\n<p>My aim in this post is to answer the following questions</p>\n<ul>\n<li>Why does <code class=\"language-text\">useCallback</code> seem problematic?</li>\n<li>Is there a simple way to reason about callback usage in React ?</li>\n</ul>\n<p>With class Components, using a callback seemed easy enough: just bind the function to the class instance and pass around the result. With the introduction of hooks, things suddenly appeared more difficult (or more subtle). The most common complaint you’ll probably hear is about stable references.</p>\n<p>With classes the callback typically follows the lifecycle of the class instance, you’ll create and bind the function only once in the constructor or using field declarations. The reference you pass around doesn’t change during this time. Also since those functions relied on <code class=\"language-text\">this.state</code> and <code class=\"language-text\">this.props</code>, they had access to the latest values which <em>seems</em> to be a correct behavior.</p>\n<p>With hooks, functions are typically created inside render functions in order to access props and state, which means we’ll get a new reference on every render. In an ideal world, this doesn’t hurt, the main benefit of <em>naked</em> callbacks is that they give us the correct state/props values which is even more crucial in Concurrent mode. But in the real world this may be undesirable because it could trigger superfluous render cycles or unwanted <code class=\"language-text\">useEffect</code> executions.</p>\n<p>The purpose of <code class=\"language-text\">useCallback</code> is to control the creation of a new reference inside render functions using the dependency management mechanism. Often in docs or tutorials, you’ll find mentions of <code class=\"language-text\">useCallback(fn, deps)</code> being just an alias for <code class=\"language-text\">useMemo(() =&gt; fn, deps)</code> (which, as we’ll see later, is not always the case from the point of view of this post). Like <code class=\"language-text\">useMemo</code>, <code class=\"language-text\">useCallback</code> is only an optimisation, it means the code should still be working without it.</p>\n<p>There is an interesting issue in the React repo called <a href=\"https://github.com/facebook/react/issues/14099\">useCallback() invalidates too often in practice</a> which refers to why the default <code class=\"language-text\">useCallback</code> behavior is not always what we want. Some appear to be valid, like I don’t want to rerender a component just because dependencies of an event handler <em>has changed</em>, the behavior of the handler is still the same (The counter argument is also valid, technically it’s not <em>the same event handler</em> if it closes over different values). As we’ll see later, which point is correct depends essentially on what kind of value is the event handler.</p>\n<p>Another interesting case concerns initiating a websocket connection only once upon mounting, then executing some socket handler regularly. We don’t want to retrigger the connection process every time something changes but the handler should always see the last committed value.</p>\n<p>The often proposed workaround is to use a mutable reference to store the function, then schedule an effect to update the values accessed by the function. A more <a href=\"https://github.com/facebook/react/issues/14099#issuecomment-440013892\">concise workaround</a> proposed in the issue is to store the changing function itself:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">useEventCallback</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> ref <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">useLayoutEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    ref<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This seems pretty good, so why not just adopt this as the default behavior for <code class=\"language-text\">useCallback</code>? we keep a stable reference while still having access to the latest value. But what’s the meaning of <em>latest values</em> here?</p>\n<p>In Concurrent mode, there could be two different answers: either we mean the last values seen in a render function, or we mean the last values used when committing to the screen. <code class=\"language-text\">useEventCallback</code> has an affinity for committed values. But there are other use cases where I want to see the last rendered values instead (e.g. render callbacks).</p>\n<p>So it may seem that the general rule is: use <code class=\"language-text\">useEventCallback</code> when doing side effects, and use the builtin <code class=\"language-text\">useCallback</code> when doing render work. Alas, it’s not that simple. Imagine the following example</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">MyComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> logger <span class=\"token operator\">=</span> <span class=\"token function\">useEventCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> tid <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>logger<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">clearTimeout</span><span class=\"token punctuation\">(</span>tid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>logger<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The code seems perfectly correct per the hooks rules, yet it won’t get the desired result. Think it a moment …</p>\n<p>The problem is that <code class=\"language-text\">useEventCallback</code> returned a stable reference for <code class=\"language-text\">logger</code>, and although the returned function can see the last committed state (which is what we want because we’re in a side effect), the effect will be executed only once since its single dependency doesn’t change. What we want though is to execute the effect <em>as soon as</em> <code class=\"language-text\">state</code> changes. We can add <code class=\"language-text\">state</code> as a dependency but the question is per what rule? <code class=\"language-text\">state</code> doesn’t appear anywhere inside the effect code. Our chosen <code class=\"language-text\">useEventCallback</code> has broken the transitivity of hooks dependencies and the rules are no longer valid.</p>\n<p>So does it mean invalidation is inevitable and we’re doomed? I don’t think so. I believe there is a way out.</p>\n<p>The example above reveals another decision factor, it’s not just about doing render vs side effects. Invalidation also plays a role in effect execution, sometimes it’s desirable to invalidate, but in other cases we’d rather keep a stable reference and use mutation to access last committed values (like in DOM event handlers).</p>\n<p>Let’s recap</p>\n<ul>\n<li>The case of render callbacks is unambiguous, <code class=\"language-text\">useCallback</code> is necessary because it gives us the minimum amount of invalidation required. We must rerender and we must access the last rendered values.</li>\n<li>\n<p>The case of side effects is more subtle</p>\n<ul>\n<li>In some cases invalidation is desirable because we want to schedule the effect execution as soon as possible.</li>\n<li>In other cases invalidation is superfluous, because we’re only interested in executing the same handler code but with the last committed values.</li>\n</ul>\n</li>\n</ul>\n<p>Is there a generic rule by which we can distinguish between the 2 last cases?</p>\n<p>Notice the similarity between render callbacks and the logger example, in both cases, we want React to <strong>output</strong> something into the external world as soon as the internal state of the application has changed.</p>\n<p>There is also a similarity between the event DOM callbacks and the websocket example. In both cases, we’ve told the external world (the user or the network) that we’re interested in receiving some kind of <strong>input</strong>. When the input arrives, we’ll decide what to do next based on the last committed state of the application. For optimisation purposes, the right amount of invalidation in this case is precisely the commit cycles triggered by state changes, the rest are just undesirable glitches.</p>\n<p>In other words it all depends on the direction of the dataflow:</p>\n<ul>\n<li>With output effects, data flows from React into the external world. We want that output to happen as soon as something changes internally.</li>\n<li>With input effects, data flows from the external world into React. We want to react to some external event, and the decision should always be based on the latest output the world has seen from us, i.e. should always be based on the last committed state.</li>\n</ul>\n<p>Which answers the 2nd question from the beginning of this post</p>\n<ul>\n<li><code class=\"language-text\">useEventCallback</code> is more suited for callbacks waiting for some external input, then changing the state of the application.</li>\n<li><code class=\"language-text\">useCallback</code> is more suited for callbacks that output something into the external world. In fact <code class=\"language-text\">useCallback</code> is semantically really an alias for <code class=\"language-text\">useMemo</code> since we’re treating functions here the same as the values we output from JSX.</li>\n</ul>\n<p>This also should explain why <code class=\"language-text\">useCallback</code> seems problematic, the same abstraction is used to handle input and output cases. But the 2 cases have incompatible semantics. It may also be a consequence of the fact that React doesn’t have a first class support for inputs. For example, input callbacks like DOM event handlers are treated like regular data that must flow to the external world every time something changes.</p>\n<p>Finally let’s answer a previous question: Is it the same event handler or not if the code stays the same but the dependencies change?</p>\n<p>As I said, it depends on what kind of value you think the event handler is. If you think of it as a regular data value, like rendered JSX, then the answer is no. If you think of the handler as a special kind of value waiting for an input: a continuation, then the answer is yes.</p>\n<p>But what if it’s not just the dependencies that changes but the code itself. This would be similar to a stateful event handler, something similar to the generators used in redux-saga. Well, in this case, I think it’s better to break things down using a mix of state, input and output code. In other words, we’ll be using a state machine where the changing behavior is taken care of by the machine’s transition function. The event handler code would be essentially to feed the machine with external input. In fact, it may be even better to extend this kind of reasoning to the whole component, in this sense JSX is just another output.</p>","frontmatter":{"title":"A simple rule for using callbacks in React","date":"January 20, 2021","description":null}},"previous":{"fields":{"slug":"/2020-09-18-continuation-category/2020-09-18-continuation-category/"},"frontmatter":{"title":"The Category of continuations"}},"next":null},"pageContext":{"id":"1796357a-dcc8-5856-b421-d675ed5ca357","previousPostId":"304e3b7a-f3f0-557a-b2da-fb9ff68e8792","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}