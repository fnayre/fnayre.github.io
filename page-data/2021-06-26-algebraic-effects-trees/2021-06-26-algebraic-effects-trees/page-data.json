{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021-06-26-algebraic-effects-trees/2021-06-26-algebraic-effects-trees/","result":{"data":{"site":{"siteMetadata":{"title":"Abstract fun"}},"markdownRemark":{"id":"633fa950-6310-5152-90c1-a8485a4077ce","excerpt":"Some time ago I wrote a series about Algebraic effects. I explained then that you could either explain the topic using Math concepts (Denotational) or by…","html":"<p>Some time ago I wrote a <a href=\"/2018-11-19-algebraic-effects-series-1\">series about Algebraic effects</a>. I explained then that you could either explain the topic using Math concepts (Denotational) or by showing how it works under some runtime environment like JavaScript (Operational). I choose the second way because I felt it would’ve been more approachable to programmers, and also because I didn’t have myself enough understanding of the Mathematical theory behind them.</p>\n<p>In retrospect, I think there is a simple way to put the denotational explanation without brining in the heavy math formalism. IMO this alternative view is better and simpler than the four lengthy posts I wrote back then. It also explains what Algebra has to do with side effects in programming.</p>\n<h1>Algebras: Specification, Construction &#x26; Evalution</h1>\n<p>Let’s start from simple algebraic expressions like <code class=\"language-text\">x + 2</code>, <code class=\"language-text\">x + (y * 3)</code> … We construct such expressions by combining variables and constants using <strong>operations</strong> like <code class=\"language-text\">+</code> or <code class=\"language-text\">*</code>. We can envision those expressions as trees branching at each operation, with variables and constants at the leaves.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 316px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e5b99e76e69dc1164a49676de2826686/67145/expr-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.88607594936708%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA7CAAAOwgEVKEqAAAAA1klEQVQ4y5WTDQuEIAyG9///ZnRBB5lafh21w0DZ2WbcQGZuPW17DZDYeZ7Vt4ue9wwkWLZlWTCEIMZFIE0uft/3y6eU/oJCC8umtcYYY3221t6g7f5WYVkURl/IUO/9Y6VADzkYjSul8DiOLrS2PAwDpvRBaab1o+uKWhsxXoHeOzaB7p1z1yyL56DQGzSFZdW3basxYwwrFEhVUU9hrVAtFKQLWhJC8Fc13B/ECQkcqCS/5xmNtayav0IpHMcXXyFNnKYJd+dERYuPMdQuHlvmZto7+wI3AFTG3L3/YgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for &#39;x + (y * 3)&#39;\"\n        title=\"Expression tree for &#39;x + (y * 3)&#39;\"\n        src=\"/static/e5b99e76e69dc1164a49676de2826686/67145/expr-1.png\"\n        srcset=\"/static/e5b99e76e69dc1164a49676de2826686/c26ae/expr-1.png 158w,\n/static/e5b99e76e69dc1164a49676de2826686/6bdcf/expr-1.png 315w,\n/static/e5b99e76e69dc1164a49676de2826686/67145/expr-1.png 316w\"\n        sizes=\"(max-width: 316px) 100vw, 316px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>To evaluate an expression, we need to assign values for the variables. In a program, we could have a function <code class=\"language-text\">evaluate(bindings, expr)</code> which computes the value of <code class=\"language-text\">expr</code>, given an object that <strong>bind</strong>s each variable in the expression to a concrete number.</p>\n<p>But we could go a little further and allow bindings to assign other sub-expressions to variables. For example, evaluating <code class=\"language-text\">x + (y * 3)</code> with a binding like <code class=\"language-text\">{ x : v, y: z - 1}</code> would substitute all occurrences of <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> to produce <code class=\"language-text\">v + ((z - 1) * 3)</code>. Visually, it’ll look like we grew the tree by inserting new sub-expressions at the leaves</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 364px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a873ff77e1f03bf2d4af15bd409e440e/e45a9/expr-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 91.13924050632912%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA4ElEQVQ4y5WS247DIAxE+f/PzOPuNhFgFxtsqFQqlC2XtH4c+WjwMKaMRkQQsVyN6aWcMzN773POX8D5Od77GGMpBRGZueofwQBQyQoAwIL/B1trK3ke730IYeUskgCwJ6tnCGGY3wtmotttnz2PiY7jUNWLm3uynd3fby5JIjrnd47TLL7ROddHBQBNHMOqmlISkf45qspM1tqcs5nVM6U064aIbNv2Dtftc8NSSp82rJI1oVa4IT8IzDnXyLbUi+/OzxrRcElVETHcQ+//gmPkfZ82jIh+f/6m8KIni8AeWn8sv/364BkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for &#39;x + (y * 3)&#39;\"\n        title=\"Expression tree for &#39;x + (y * 3)&#39;\"\n        src=\"/static/a873ff77e1f03bf2d4af15bd409e440e/e45a9/expr-2.png\"\n        srcset=\"/static/a873ff77e1f03bf2d4af15bd409e440e/c26ae/expr-2.png 158w,\n/static/a873ff77e1f03bf2d4af15bd409e440e/6bdcf/expr-2.png 315w,\n/static/a873ff77e1f03bf2d4af15bd409e440e/e45a9/expr-2.png 364w\"\n        sizes=\"(max-width: 364px) 100vw, 364px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>Specification</h2>\n<p>Mathematicians have a nasty obssession for abstractions. For instance, instead of talking about adding 2 integers, they would abstract away some common properties, like the fact that addition is associative (<code class=\"language-text\">x + (y + z) = (x + y) + z</code>) and then define a sort of abstract interface (for associativity, they call it a <em>Semigroup</em>). Any Set with an operation that satisfies the above equation could be considered an instance of that interface.</p>\n<p>There is a whole catalogue of those <em>Algebraic structures</em> that are studied in the field of Abstract Algebra. But we’re not interested in them. What’s important to us is, like the separation interface/class, we distill the process: first we define of a bunch of abstract operations in terms of some <em>equations</em> that must be satisfied, and then pick a concrete Set together with some functions that implement the specified operations in a way that satisfies the required equations (e.g. integers and integer addition, or strings and concatenation).</p>\n<p>The abstract operations and their equational laws can be grouped together under what’s called an <em>Algebraic Theory</em>, that’s the interface. A concrete Set together with functions that interpret all operations is called a <em>Model</em> for the specific Algebraic Theory, that’s the implementation. As you might expect, there is also a special name for the concrete Set used by the model: it’s called the <em>carrier</em> of the model.</p>\n<p>For example, we can describe the theory of a Monoid through 2 operations, <code class=\"language-text\">zero</code> and <code class=\"language-text\">add</code></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// We're just specifying the operations, no equational laws</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Monoid<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Model using `number` as carrier</span>\n<span class=\"token keyword\">const</span> MNum<span class=\"token operator\">:</span> Monoid<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">zero</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> left <span class=\"token operator\">+</span> right\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Construction</h2>\n<p>One thing you will not find in the interface/class analogy is that there is a systematic way to construct an implementation for each interface (i.e. a Model for each Algebraic Theory). It’s really simple, pick any Set, then for each operation, just take the given information <em>as is</em> and keep it.</p>\n<p>For instance instead of interpreting the expression <code class=\"language-text\">2 + 3</code> as <code class=\"language-text\">5</code> (losing the <em>initial information</em> about <code class=\"language-text\">2</code> and <code class=\"language-text\">3</code> in the process), we can construct <em>an expression tree</em> (with integers in the leaves) for our Model. Think of it as constructing an Abstract Syntax Tree (AST) without any further evaluation (we also use equational laws to group trees under equivalent classes but that’s not important for us).</p>\n<p>And yes, those trees have also got a special name, they are called <em>Free Models</em>.</p>\n<p>For example, to construct the free model for Monoids, we could write someting like</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// we'll use a label `pure` to inject values in the leaves</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">;</span> value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"zero\"</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"add\"</span><span class=\"token punctuation\">;</span> left<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> right<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">pure</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">,</span> value <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">zero</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"zero\"</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">add</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"add\"</span><span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// No evaluation, just collecting information</span>\n<span class=\"token keyword\">let</span> expr <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">pure</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">pure</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2>Evaluation</h2>\n<p>To evaluate expression trees, we can write a function that goes recursively over the tree. But we can write a general purpose function that constructs a tree evaluator from any given model.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">fold</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>model<span class=\"token operator\">:</span> Monoid<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> tree<span class=\"token punctuation\">.</span>value\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"zero\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">.</span><span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> interpreter <span class=\"token operator\">=</span> <span class=\"token function\">fold</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">zero</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> left <span class=\"token operator\">+</span> right\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"result\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">interpreter</span><span class=\"token punctuation\">(</span>expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Observe how we’ve abstracted away recursion from the model and encapsulated it inside <code class=\"language-text\">fold</code>. Thr Model had only to provide a <em>shallow</em> interpreter for the operations. We’ll see a similar behavior when taking about Handlers for Algebraic Effects.</p>\n<blockquote>\n<p>In fact <code class=\"language-text\">fold</code> is very similar to the <code class=\"language-text\">reduce</code> method of JavaScript arrays. If you think of Array as an algebraic theory with a pair of operations <code class=\"language-text\">[]</code> and <code class=\"language-text\">[head, ...tail]</code>, then a model has to provide 2 functions: the first simply selects an element for the case of <code class=\"language-text\">[]</code> (the second paramater of <code class=\"language-text\">reduce</code>), and the second combines <code class=\"language-text\">head</code> and <code class=\"language-text\">tail</code> (the first parameter of <code class=\"language-text\">reduce</code>). Semantically, <code class=\"language-text\">reduce</code> acts like a <code class=\"language-text\">fold</code> specialized to arrays.</p>\n</blockquote>\n<h1>Programs</h1>\n<p>There are various mental models to envision a program. The idiomatic, the most evident, is to imagine a series of successive steps. In this model, the program invokes commands that gets interpreted by some machine. After each command, the machine would transition from a state to another. We can charachterize this point of view as imperative, and it’s often made formal by computer scientists using some sort of state machine.</p>\n<p>But there is also a declarative point of view, we can imagine a program as one big expression. The expression is handed as a tree to an interpreter that then chooses a suitable evlaluation for the operations (like integer addition for <code class=\"language-text\">+</code> etc).</p>\n<p>One could object that the above could only work in the case of simple mathematical expressions, or using the programming language jargon, in the case of <strong>pure expressions</strong>. For example, how would <code class=\"language-text\">console.log</code> or <code class=\"language-text\">fetch</code> look like in a tree?</p>\n<p>More generally, the question is: how do we get a tree-like representation of <strong>side effects</strong>. And since we saw earlier that our trees are just free models of algebraic theories, the question translates to: could we have an algebraic representation of side effects?</p>\n<p>We saw that algebraic expressions are constructed by operations that combine other sub expressions. Let’s observe that every operation can take a fixed number of arguments. Common arithmetic operations like <code class=\"language-text\">+</code> or <code class=\"language-text\">*</code> are generally binary (taking 2 arguments), but that’s not mandatory, for <code class=\"language-text\">-3</code> we can view <code class=\"language-text\">-</code> as an unary operation (taking a single argument). The number of arguments an operation takes is called its <strong>arity</strong>.</p>\n<p>In order to fit side effects in this picture, we need to adopt a wider view of the concept of arity. Let’s take for example the side effect of getting a random value from the environement (like <code class=\"language-text\">Math.random()</code> in JavaScript). The imperative view represents the side effect as an action which would modify the external world then returns a value. The program would then continue in the <em>new version</em> of the world.</p>\n<p>We could represent the effect with a <code class=\"language-text\">random</code> operation, but this time with a kind of an <strong>infinite arity</strong>. For example, say <code class=\"language-text\">random</code> returns only arbitrary integers, then the arity would be the number of all integers. Visually we’ll have a tree with the <code class=\"language-text\">random</code> operation at its root, and a branch for each possible answer that can be returned by the operation</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cb8e601f2ff81419f463253ce76c4572/42d54/expr-3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.253164556962027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAaklEQVQY022OiQnAMAwDs/+e7QZ+8llFAUNSYhAWh/wUAIgIZO2e5WZ43hcicnDmMrvPlB3uvrUGFYWqotYKM1uefIxxnaHK/wIHqFyCCLj7yrCTZ79+yGsJ6Hvvy885D54fkLOYo3JV5j8kCjxrAoZNQwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for random operation\"\n        title=\"Expression tree for random operation\"\n        src=\"/static/cb8e601f2ff81419f463253ce76c4572/f058b/expr-3.png\"\n        srcset=\"/static/cb8e601f2ff81419f463253ce76c4572/c26ae/expr-3.png 158w,\n/static/cb8e601f2ff81419f463253ce76c4572/6bdcf/expr-3.png 315w,\n/static/cb8e601f2ff81419f463253ce76c4572/f058b/expr-3.png 630w,\n/static/cb8e601f2ff81419f463253ce76c4572/42d54/expr-3.png 858w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Another example <code class=\"language-text\">console.log</code> can be seen as a function taking the message to log and returning a (parameterized) <code class=\"language-text\">log</code> operation. What’s its arity? think about it this way: in the case <code class=\"language-text\">random</code> there could be, potentially, as many ways to continue the program as there are possible answer values. But since<code class=\"language-text\">log</code> returns a unique meaningless value (e.g. <code class=\"language-text\">undefined</code>) then there could be only one way to continue the program (simply the code after <code class=\"language-text\">console.log</code>).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 147px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/279927faaed38b000558f3e6a2565adf/a70ce/expr-4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 121.7687074829932%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAIAAAB1KUohAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABPUlEQVQ4y+2UT0+DMBiH9/0/gcniEuN2ds5k7maICAhOAqiX4USdgJrxp8Bho29r2m4TMc5s0YOJTzhA2+d9219SGpRDCKFLCCEAwF9AjACAWCCmVksbFQELqlUwxkzkfnVqIYuST4+Tcl6Kbt54bNsOpdTz7jBrA67r+n5AKY1eQ+f6Jo4ispSZcnTYleVTzRj2ewemczUa3VKYNZs7J2fauSK39/e6vb5l2mEYevcPpnmZpGixbSjnuiprqtLptFu7LW/CmhRFbujK4HigabqqKpIkGRfDkodgWWaWF+9nFmQoQVmOEKJfAxgjlH4MrJJnLXayAqAeWO27WmLKqVVcJ1dLPHO2lF84//IfkIMg8H1/S9myLF3XN5YFtX/DZvK3/I4MgNmDAT7dxHWyiCdN4ogxjeJYDP/wtt8Am7J7j9hUdIcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for random operation\"\n        title=\"Expression tree for random operation\"\n        src=\"/static/279927faaed38b000558f3e6a2565adf/a70ce/expr-4.png\"\n        srcset=\"/static/279927faaed38b000558f3e6a2565adf/a70ce/expr-4.png 147w\"\n        sizes=\"(max-width: 147px) 100vw, 147px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>One more example, <code class=\"language-text\">throw</code> could be seen as a function taking the error to be thrown and returning an <code class=\"language-text\">abort</code> operation. How many ways are there for the program to continue after <code class=\"language-text\">abort</code>? None! It’s a dead end, so the arity of <code class=\"language-text\">abort</code> is <code class=\"language-text\">0</code> (of course the program could possibly continue with an exception handler, but that’s the other side of the story).</p>\n<p>we need one last generalisation of the arity concept. For instance, in order to represent the <code class=\"language-text\">random</code> program above in code, we’d have to provide an argument for each possible answer, something like</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">[</span>rest <span class=\"token keyword\">if</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>rest <span class=\"token keyword\">if</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>rest <span class=\"token keyword\">if</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>But it’s impossible. Fortunately there is a feasible formulation</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// return children depending on `n`</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Sometimes the simplest solution is a function.</p>\n<p>In this setting, a function acts like a dictionary whose size is exactly that of the possible answers expected from the operation. More formally, if <code class=\"language-text\">integer</code> is the type of integer expressions in our programming language, then w’d say that <code class=\"language-text\">random</code> has an arity of <code class=\"language-text\">integer</code>.</p>\n<p>Observe also that the equivalence is general, a binary operation <code class=\"language-text\">add(x,y)</code> can also be written <code class=\"language-text\">add(b =&gt; b ? x : y)</code> and we could also say that <code class=\"language-text\">add</code> has a <code class=\"language-text\">boolean</code> arity (note that we’re not adding/evaluating anything here, we’re just constructing the tree that represents the expression).</p>\n<p>There is nothing fancy here, from a programming point of view, the function passed to the operation is just a <em>continuation</em> that takes the answer from the performed operation and return the rest of the program. It turns out that the continuation is a general representation for tuples of any arity.</p>\n<p>In our earlier implemetation of simple Monoid expessions, we used interfaces to represent operations. And this is the way to go for all operations provided we have a sufficiently powerful type system to track side effects. In the rest I’ll just use a generic operation object.</p>\n<p>More specifically, a program can be either</p>\n<ul>\n<li>a Leaf : a pure value, code doesn’t perform any operation or side effect</li>\n<li>a Subtree: an Operation together with a continuation that specifies the subtree’s children or the rest of the computation</li>\n</ul>\n<p>In typescript this would be something like</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">;</span> value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span>\n      tag<span class=\"token operator\">:</span> <span class=\"token string\">\"operation\"</span>\n      name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n      params<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span>\n      <span class=\"token function-variable function\">resume</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>Observe we use <code class=\"language-text\">any</code> for the type of arity. We need a feature called <em>existential types</em> in order to have a more typesafe signature. We also store the parameters that were passed to the operation.</p>\n</blockquote>\n<p>In the rest I’ll use just Javascript. We’ll represent leaves as plain javascript expressions, and operations with a special object type</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">id</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> params <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> resume <span class=\"token operator\">=</span> id</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> _IS_OPERATION_<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> resume <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>for example</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> random <span class=\"token operator\">=</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"random\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// { _IS_OPERATION_: true, name: \"random\", params: [], resume: id }</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">message</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"log\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>message<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// { _IS_OPERATION_: true, name: \"log\", params: [\"hello\"], resume: id }</span></code></pre></div>\n<p>Obviously we can’t write entire programs in one hard-coded giant expression tree. Observe that the <code class=\"language-text\">resume</code> parameter already defaults to the identity function, which means that by default the program performs the operation then returns the answer provided by the external environment.</p>\n<p>The default identity continuation allows us to create small <em>truncated</em> programs. what we need is a way to assemble bigger programs (trees) from smaller programs (subtrees). We can acheive this by exploiting the <em>binding</em> operation we saw earlier with simple math expressions. Binding will allow us to extend the program tree by replacing leaves (i.e. pure values) with further subtrees (rest of the program).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">program<span class=\"token punctuation\">,</span> then</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>program<span class=\"token operator\">?.</span>_IS_OPERATION_<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">then</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> resume <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> program\n    <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> <span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> then<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">bind</code> takes a subprogram and a continuation. If the subprogram is a leaf/pure value, we apply the contiuation immediately to get the rest of the program. This corresponds to ‘substitute a leaf with a subtree’ case. Otherwise we need to call <code class=\"language-text\">bind</code> recursively on all subtrees (the <code class=\"language-text\">a =&gt; bind(resume(a), then)</code>, think of <code class=\"language-text\">resume</code> as a big dictionary: Each entry <code class=\"language-text\">{a: resume(a)}</code> in the dictionary is replaced by <code class=\"language-text\">{a: bind(resume(a), then)}</code>).</p>\n<p>For example, going from <code class=\"language-text\">log(&quot;hello&quot;)</code> to <code class=\"language-text\">bind(log(&quot;hello&quot;), _ =&gt; random)</code> could be visually represented as</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 605px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/15f9c153d8719ed55fc8729fe86764ea/90cbd/expr-5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.177215189873415%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7CAAAOwgEVKEqAAAAAr0lEQVQoz21QCQ7DIAzj/19lVVsK5caT2cLYRqQoymUnVg+tse87cs5YWWutR2NOaK3hnPvrzaYIVGsdA9573PfdPaU06pyZc4m/oMoYA7o0SMBFeillDBLwOI8v8hWwuq6rA9bF+TOYsxbbtsFa14lWYIxqpZkMcJGXUjdKEVNCjLHnjPMH40IBEJ1ejYYQAmLk23loxxotvYEpj9RkX620oAv7hwQok36i5dzny0+yMCkUpGLK+gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for random operation\"\n        title=\"Expression tree for random operation\"\n        src=\"/static/15f9c153d8719ed55fc8729fe86764ea/90cbd/expr-5.png\"\n        srcset=\"/static/15f9c153d8719ed55fc8729fe86764ea/c26ae/expr-5.png 158w,\n/static/15f9c153d8719ed55fc8729fe86764ea/6bdcf/expr-5.png 315w,\n/static/15f9c153d8719ed55fc8729fe86764ea/90cbd/expr-5.png 605w\"\n        sizes=\"(max-width: 605px) 100vw, 605px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>One more caveat is that writing programs using nested <code class=\"language-text\">bind</code>s is akin to writing in continuation passing style, which is tedious and impractical.</p>\n<p>First, let me clarify that the above implementation is just intented as a pedagogical tool. A real implementation of algebraic effects would typically be backed by a programming language, not only to provide an ergonomic way to write programs, but also to generate an efficient executable.</p>\n<p>But still, we’d have to see how our tree representation maps to a traditional code written in a seqeuntial way. In the case of JavaScript, we can use Generator functions to create and bind programs using the sequential style. So for example one would write</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> fetchUser\n  <span class=\"token keyword\">let</span> repos <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> fetchRepos\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> user<span class=\"token punctuation\">,</span> repos <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>instead of</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>fetchUser<span class=\"token punctuation\">,</span> <span class=\"token parameter\">user</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>fetchRepos<span class=\"token punctuation\">,</span> <span class=\"token parameter\">repos</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> user<span class=\"token punctuation\">,</span> repos <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Below a simple (and ineffecient) implementation for transforming Generator functions into <code class=\"language-text\">bind</code> expressions, I won’t be commenting the code because the post is already getting long. The code supports resuming the <code class=\"language-text\">bind</code> continuation multiple times (which means the computation can take many paths in the tree).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">gf<span class=\"token punctuation\">,</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> history <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">gf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> history<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_<span class=\"token punctuation\">,</span> x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span>value\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token function\">go</span><span class=\"token punctuation\">(</span>gf<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">,</span> history<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> program <span class=\"token operator\">=</span> <span class=\"token function\">go</span><span class=\"token punctuation\">(</span>fetchData<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// // { _IS_OPERATION_: true, name: \"fetchUser\", params: [], resume: ... }</span></code></pre></div>\n<p>We’ve talked about construction, but what about evaluation? That where handlers fit in the story. Operationally, handlers are presented as a generalisation of exception handlers that can resume the program from the point that threw the exception.</p>\n<p>In our declarative representation, a handlers is just another expression evaluator, like the one we saw earlier for Monoids.</p>\n<p>Let’s recall how we implemented the interpreter for our earlier Monoid theory. Given any Model for the Monoid theory, <code class=\"language-text\">fold</code> generates an interpreter for a monoid tree (the free model)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> fold<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>model<span class=\"token operator\">:</span> Monoid<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">tree<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> tree<span class=\"token punctuation\">.</span>value\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"zero\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">.</span><span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> interpreter <span class=\"token operator\">=</span> <span class=\"token function\">fold</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">zero</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> number<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> number <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> left <span class=\"token operator\">+</span> right\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">fold</code> first handles the <code class=\"language-text\">pure</code> case by returning the pure value (i.e. carrier value). Then for each operation, we start by recursively evaluating its children, then we use the model to recombine the computed values.</p>\n<p>Our programs are just expressions with a general notion of arity for the operations. So we can take the same implementation and adapt it.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">model</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">tree</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>tree<span class=\"token operator\">?.</span>_IS_OPERATION_<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> h<span class=\"token punctuation\">.</span>return <span class=\"token operator\">?</span> h<span class=\"token punctuation\">.</span><span class=\"token function\">return</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> tree\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> resume <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> tree\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>name <span class=\"token keyword\">in</span> model<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>params<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In our new interface, we’re dealing with generic operations, so we need to pass the operation’s parameters to the model. The model gets also a continuation representing the rest of the program (or the operation’s children). Just like <code class=\"language-text\">fold</code>, <code class=\"language-text\">handler</code> calls the evaluator recursively on the operations’s children (all <code class=\"language-text\">x =&gt; evaluate(resume(x))</code> calls).</p>\n<p>We’re also adding another clause, if our model doesn’t handle the current operation, then we <em>bubble</em> it up to upstream handlers. But in the meantime, the handler wraps itself around the operation. In the tree language, the model just ignores the operation node and tries to evaluate all its children instead.</p>\n<p>Finally, we allow the model to preprocess the return value of the program (the leaves) using a special method <code class=\"language-text\">return</code>. This is needed to allow the handler to change the return value of a program (like a handler for a program performing <code class=\"language-text\">state</code> effects can return stateful functions <code class=\"language-text\">state -&gt; [value, state]</code>).</p>\n<p>To highlight the analogy, here’s a reimplementation of Monoids using the new generic interface</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zero\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">left<span class=\"token punctuation\">,</span> right</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"add\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">b</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">?</span> left <span class=\"token operator\">:</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> interpreter <span class=\"token operator\">=</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">zero</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resume</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">zero</code> is a nullary operation, just like the earlier <code class=\"language-text\">abort</code> example. The case of <code class=\"language-text\">add</code> is more interesting, it calls its continuation twice in order to reach both children. Like in the former implementation, the handler doesn’t bother with recursion and performs the addition directly on the results of <code class=\"language-text\">resume</code>, the recursion is taken care by <code class=\"language-text\">handler</code>.</p>\n<p>Another thing I’d like to emphasize: even if a programming language makes it look like calling operations is just simple function invocation, it’s not. The distinction between pure values and effectful ones is core to the theory behind Algebraic Effects, it’s core to the theory behind Monads and it’s core to any modelling of computational effects (If it were not, we wouldn’t need fancy theories about side effects, simple mathematical functions would’ve been sufficient). What makes Algebraic Effects interesting (among other things) is that functions are typically polymorphic over Effects so one for example wouldn’t need a special <code class=\"language-text\">mapM</code> function like with Monads.</p>\n<p>By the way, if you have smelled the Monad in the above, it’s because our programs are rightly instances of a Monad (It’s much more flexible than the usual Monads and so called the <code class=\"language-text\">Freer Monad</code>). You could also apply the Tree trick in the case of usual Monads as well.</p>\n<p>There’s more to be said like the relation between Algebraic Theories and Monads, maybe for a future post. In the meantime, I hope the post gave you a better intuition on the relation between Algebra and side effects.</p>\n<h1>Resources</h1>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1807.05923\">What is algebraic about algebraic effects and handlers?</a></li>\n<li><a href=\"http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html?m=1\">Monads are Trees with Grafting</a></li>\n<li><a href=\"http://okmij.org/ftp/Haskell/extensible/exteff.pdf\">Extensible Effects</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=6t6bsWVOIzs\">A Categorical View of Computational Effects</a></li>\n</ul>","frontmatter":{"title":"Programs as Trees or what's algebraic about Algebraic Effects","date":"June 26, 2021","description":null}},"previous":{"fields":{"slug":"/2021-01-20-react-callbacks/"},"frontmatter":{"title":"A simple rule for using callbacks in React"}},"next":null},"pageContext":{"id":"633fa950-6310-5152-90c1-a8485a4077ce","previousPostId":"1796357a-dcc8-5856-b421-d675ed5ca357","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}