{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021-06-26-algebraic-effects-trees/2021-06-26-algebraic-effects-trees/","result":{"data":{"site":{"siteMetadata":{"title":"Abstract fun"}},"markdownRemark":{"id":"540d8f61-3608-5d8a-9ecd-728cee3c8b91","excerpt":"Some time ago I wrote a series about Algebraic effects. I explained then that you could either explain the topic using Math concepts (Denotational) or by…","html":"<p>Some time ago I wrote a <a href=\"/2018-11-19-algebraic-effects-series-1\">series about Algebraic effects</a>. I explained then that you could either explain the topic using Math concepts (Denotational) or by showing how it works under some runtime environment like JavaScript (Operational). I choose the second way because I felt it would’ve been more approachable to programmers, and also because I didn’t have myself enough understanding of the Mathematical theory behind them.</p>\n<p>I think there is a simple way to put the denotational explanation without brining in the heavy math formalism. IMO this alternative view is better and simpler than the four lengthy posts I wrote back then. It also explains what Algebra has to do with side effects in programming.</p>\n<h1>Algebras</h1>\n<p>Let’s start from simple algebraic expressions like <code class=\"language-text\">x + 2</code>, <code class=\"language-text\">x + (y * 3)</code> … We construct such expressions by combining variables and constants using <strong>operations</strong> like <code class=\"language-text\">+</code> or <code class=\"language-text\">*</code>. We can envision those expressions as trees branching at each operation, with variables and constants at the leaves.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 316px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e5b99e76e69dc1164a49676de2826686/67145/expr-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.88607594936708%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA7CAAAOwgEVKEqAAAAA1klEQVQ4y5WTDQuEIAyG9///ZnRBB5lafh21w0DZ2WbcQGZuPW17DZDYeZ7Vt4ue9wwkWLZlWTCEIMZFIE0uft/3y6eU/oJCC8umtcYYY3221t6g7f5WYVkURl/IUO/9Y6VADzkYjSul8DiOLrS2PAwDpvRBaab1o+uKWhsxXoHeOzaB7p1z1yyL56DQGzSFZdW3basxYwwrFEhVUU9hrVAtFKQLWhJC8Fc13B/ECQkcqCS/5xmNtayav0IpHMcXXyFNnKYJd+dERYuPMdQuHlvmZto7+wI3AFTG3L3/YgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for &#39;x + (y * 3)&#39;\"\n        title=\"Expression tree for &#39;x + (y * 3)&#39;\"\n        src=\"/static/e5b99e76e69dc1164a49676de2826686/67145/expr-1.png\"\n        srcset=\"/static/e5b99e76e69dc1164a49676de2826686/c26ae/expr-1.png 158w,\n/static/e5b99e76e69dc1164a49676de2826686/6bdcf/expr-1.png 315w,\n/static/e5b99e76e69dc1164a49676de2826686/67145/expr-1.png 316w\"\n        sizes=\"(max-width: 316px) 100vw, 316px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>To evaluate an expression, we need to assign values for the variables. In a program, we could have a function <code class=\"language-text\">evaluate(bindings, expr)</code> which computes the value of <code class=\"language-text\">expr</code>, given an object that <strong>bind</strong>s each variable in the expression to a concrete number.</p>\n<p>But we could go a little further and allow bindings to assign other sub-expressions to variables. For example, evaluating <code class=\"language-text\">x + (y * 3)</code> with a binding like <code class=\"language-text\">{ x : v, y: z - 1}</code> would substitute all occurrences of <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> to produce <code class=\"language-text\">v + ((z - 1) * 3)</code>. Visually, it’ll look like we grew the tree by inserting new sub-expressions at the leaves</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 364px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a873ff77e1f03bf2d4af15bd409e440e/e45a9/expr-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 91.13924050632912%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA4ElEQVQ4y5WS247DIAxE+f/PzOPuNhdsBwM2VCqrCIVL23m0fLA9jMk9iQidlN/JtKWUkvceAFJKX8DpJQAIIeScich7X+ofwYhYyAIg4oQ3NbnveyFrWWudc7PJIhGRWrI86pwjpCHsmR/rOlrPM2/bpqpvbm5JRGTm7v1mTgJAIS//ajvN5Bu7VgHAVezDqhpjFJF2HVVl5uM4Ukp9OL40yoaILMtyh0t3nbAY40cJu8jrpDqqN75jmLW2eFs3tcX75BKjbpOqEtF5unb+PxyCX8cJY+bfn78hPMnJxLAnFrEsmyOngEkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for &#39;x + (y * 3)&#39;\"\n        title=\"Expression tree for &#39;x + (y * 3)&#39;\"\n        src=\"/static/a873ff77e1f03bf2d4af15bd409e440e/e45a9/expr-2.png\"\n        srcset=\"/static/a873ff77e1f03bf2d4af15bd409e440e/c26ae/expr-2.png 158w,\n/static/a873ff77e1f03bf2d4af15bd409e440e/6bdcf/expr-2.png 315w,\n/static/a873ff77e1f03bf2d4af15bd409e440e/e45a9/expr-2.png 364w\"\n        sizes=\"(max-width: 364px) 100vw, 364px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>Specification</h2>\n<p>Mathematicians have a nasty obsession for abstractions. For instance, instead of talking about adding 2 integers, they would abstract away some common properties, like the fact that addition is associative (<code class=\"language-text\">x + (y + z) = (x + y) + z</code>) and then define a sort of abstract interface (for associativity, they call it a <em>Semigroup</em>). Any Set with an operation that satisfies the above equation could be considered an instance of that interface.</p>\n<p>There is a whole catalogue of those abstract interfaces, or <em>Algebraic structures</em> as they are called, that are studied in the field of Abstract Algebra. But we’re not interested in them. What’s important to us is, like the separation interface/class, we distill the process: first we define of a bunch of abstract operations in terms of some equations that must be satisfied, and then pick a concrete Set, then define some functions on that Set that implement the specified operations in a way that satisfies the required equations.</p>\n<p>The abstract operations and their ‘equational laws’ can be grouped together under what’s called an <strong>Algebraic Theory</strong>, that’s the interface. A concrete Set together with functions that interpret all operations is called a <strong>Model</strong> for the specific Algebraic Theory, that’s the implementation. As you might expect, there is also a special name for the concrete Set used by the Model: it’s called the <strong>Carrier</strong> of the Model.</p>\n<p>For example, we can describe the theory of a Monoid through 2 operations, <code class=\"language-text\">zero</code> and <code class=\"language-text\">add</code> (To keep things simple, we occult equational laws).</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Monoid<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Then define a Model using the Set of numbers as carrier (we abuse here by equating Sets with Types)</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> MNum<span class=\"token operator\">:</span> Monoid<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">zero</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> left <span class=\"token operator\">+</span> right\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Similarly we can use strings as carrier</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> MString<span class=\"token operator\">:</span> Monoid<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">zero</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> left <span class=\"token operator\">+</span> right\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Construction</h2>\n<p>One thing you will not find in the interface/class analogy is that there is a systematic way to construct an implementation for each interface (i.e. a Model for each Algebraic Theory). It’s really simple, pick any Set, then for each operation, just take the given information <em>as is</em> and keep it.</p>\n<p>For instance instead of interpreting the expression <code class=\"language-text\">2 + 3</code> as <code class=\"language-text\">5</code> (losing the <em>initial information</em> about <code class=\"language-text\">2</code> and <code class=\"language-text\">3</code> in the process), we can construct <em>an expression tree</em> (with integers in the leaves) as our Model. Think of it as constructing an Abstract Syntax Tree (We should also consider trees that are considered identical under equational laws as one but that’s not important for us).</p>\n<p>And yes, those trees have also got a special name, they are called <strong>Free Models</strong>.</p>\n<p>For example, to construct a Free Model for Monoids over given Set <code class=\"language-text\">A</code>, we could write someting like</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// we'll use a label `pure` to inject values in the leaves</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">;</span> value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"zero\"</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"add\"</span><span class=\"token punctuation\">;</span> left<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> right<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">pure</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">,</span> value <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">zero</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"zero\"</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">add</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"add\"</span><span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// No evaluation, just collecting information</span>\n<span class=\"token keyword\">let</span> expr <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">pure</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">pure</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2>Evaluation</h2>\n<p>To evaluate expression trees, we can write a function that goes recursively over the tree. But Math allows us to do better, a general purpose function that constructs a tree evaluator from any given Model.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">fold</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>model<span class=\"token operator\">:</span> Monoid<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> tree<span class=\"token punctuation\">.</span>value\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"zero\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">.</span><span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> interpreter <span class=\"token operator\">=</span> <span class=\"token function\">fold</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">zero</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> left <span class=\"token operator\">+</span> right\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"result\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">interpreter</span><span class=\"token punctuation\">(</span>expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Observe how we’ve abstracted away recursion from the Model and encapsulated it inside <code class=\"language-text\">fold</code>. Thr Model had only to provide a <em>shallow</em> interpreter for the operations. We’ll see a similar behavior when talking about Effect Handlers (There’s more to say about this actually, <code class=\"language-text\">evaluate</code> is guaranteed to exist because of the mathematical properties of Free Models, but that’s story for another day).</p>\n<p>In fact <code class=\"language-text\">fold</code> is very similar to the <code class=\"language-text\">reduce</code> method of JavaScript arrays. If you think of ‘Array’ as an Algebraic Theory with a pair of operations <code class=\"language-text\">[]</code> and <code class=\"language-text\">[head, ...tail]</code>, then a Model has to provide 2 functions: the first simply selects an element for the case of <code class=\"language-text\">[]</code> (the second paramater of <code class=\"language-text\">reduce</code>), and the second combines <code class=\"language-text\">head</code> and <code class=\"language-text\">tail</code> (the first parameter of <code class=\"language-text\">reduce</code>). Semantically, a (well behaved) <code class=\"language-text\">reduce</code> acts like a <code class=\"language-text\">fold</code> specialized to arrays.</p>\n<h1>Programs</h1>\n<p>There are various mental models to envision a program. The most common is to imagine a series of successive steps. In this model, the program invokes commands that gets interpreted by some machine. After each command, the machine would transition from a state to another. We can charachterize this point of view as imperative, and it’s often made formal by computer scientists using some sort of state machine.</p>\n<p>But there is also a declarative point of view, we can imagine a program as one big expression. The expression is handed as a tree to an interpreter that then chooses a suitable evlaluation for the operations.</p>\n<p>One could object that the above could only work in the case of simple mathematical expressions, or using the programming language jargon, in the case of pure expressions. How would things like <code class=\"language-text\">console.log</code> or <code class=\"language-text\">fetch</code> look like in a tree?</p>\n<p>More generally, the question is: how do we get a tree-like representation of side effects. And since we saw earlier that our trees are just Free Models of Algebraic Theories, the question translates to: could we have an algebraic representation of side effects?</p>\n<p>We saw that algebraic expressions are constructed by operations that combine other subexpressions. Let’s observe that every operation can take a fixed number of arguments. Common arithmetic operations like <code class=\"language-text\">+</code> or <code class=\"language-text\">*</code> are generally binary (taking 2 arguments). In <code class=\"language-text\">-3</code> we can view <code class=\"language-text\">-</code> as a unary operation (taking a single argument). The number of arguments an operation takes is called its <strong>arity</strong>.</p>\n<p>In order to fit side effects in this picture, we need to adopt a wider view of the concept of arity. Let’s take for example the side effect of getting a random value from the environement (like <code class=\"language-text\">Math.random()</code> in JavaScript). The imperative view envision the side effect as an action which would modify the external world then returns a value. The program would then continue in the new version of the world.</p>\n<p>But we could represent the effect with a <code class=\"language-text\">random</code> operation, but this time with a kind of an <strong>infinite arity</strong>. For example, say <code class=\"language-text\">random</code> returns only arbitrary integers, then the arity would be the number of all integers. Visually we’ll have a tree with the <code class=\"language-text\">random</code> operation at its root, and a branch for each possible answer that can be returned by the operation</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cb8e601f2ff81419f463253ce76c4572/42d54/expr-3r.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.253164556962027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAaklEQVQY022OiQnAMAwDs/+e7QZ+8llFAUNSYhAWh/wUAIgIZO2e5WZ43hcicnDmMrvPlB3uvrUGFYWqotYKM1uefIxxnaHK/wIHqFyCCLj7yrCTZ79+yGsJ6Hvvy885D54fkLOYo3JV5j8kCjxrAoZNQwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for random operation\"\n        title=\"Expression tree for random operation\"\n        src=\"/static/cb8e601f2ff81419f463253ce76c4572/f058b/expr-3r.png\"\n        srcset=\"/static/cb8e601f2ff81419f463253ce76c4572/c26ae/expr-3r.png 158w,\n/static/cb8e601f2ff81419f463253ce76c4572/6bdcf/expr-3r.png 315w,\n/static/cb8e601f2ff81419f463253ce76c4572/f058b/expr-3r.png 630w,\n/static/cb8e601f2ff81419f463253ce76c4572/42d54/expr-3r.png 858w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Another example <code class=\"language-text\">console.log</code> can be seen as a function taking the message to log and returning a (parameterized) <code class=\"language-text\">log</code> operation. What’s its arity? think about it this way: in the case <code class=\"language-text\">random</code> there could be, potentially, as many ways to continue the program as there are possible answer values. But since<code class=\"language-text\">log</code> returns a unique meaningless value (e.g. <code class=\"language-text\">undefined</code>) then there could be only one way to continue the program (simply the code after <code class=\"language-text\">console.log</code>).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 147px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/279927faaed38b000558f3e6a2565adf/a70ce/expr-4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 121.7687074829932%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAIAAAB1KUohAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABQElEQVQ4y+2TTVPCMBCG+///guAJPDuI4hHGaZhWRhqQW/lQQKY6BtPCQdrdZbrhW0Vx9OCMz6lN9tkkbyYWMYhISxARAPgDzAgAmIJ0CmFVay0NYiUt2+my1gBoG8vMDfuDeBabom6nLWWDiHq9bpIK4Pvt4cOIiNTTSN62xmrMK6Bl+p6fFWxhO7WbUvFUNlu+30F4Pc4eVYTrVsVJPlcoXja8ZhAEd/d96dW1DhfbhnjmiCsh7Fw+l81kuoN0kel04jh26aJUrTpC2OVK2b2uxbxxKetRNN04MxPplzCaaB0hfUiSxGGotwIDTsuceWUuAoQ1u4Ft/iDiKlsiemZ2LpJv5j15swsRBcxbmb4iPzL/8h+QR8w3Zc/zXNc9WDbEzJ6CffKn/I6cJJAsOUA28eixUorfpFLbD/GHtj0HJLx7kQJsalEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for random operation\"\n        title=\"Expression tree for random operation\"\n        src=\"/static/279927faaed38b000558f3e6a2565adf/a70ce/expr-4.png\"\n        srcset=\"/static/279927faaed38b000558f3e6a2565adf/a70ce/expr-4.png 147w\"\n        sizes=\"(max-width: 147px) 100vw, 147px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>One more example, <code class=\"language-text\">throw</code> could be seen as a function taking the error to be thrown and returning an <code class=\"language-text\">abort</code> operation. How many ways are there for the program to continue after <code class=\"language-text\">abort</code>? None! It’s a dead end, so the arity of <code class=\"language-text\">abort</code> is <code class=\"language-text\">0</code> (of course the program could possibly continue with an exception handler, but that’s the other side of the story).</p>\n<p>we need one last generalisation of the arity concept. For instance, in order to represent the <code class=\"language-text\">random</code> program above in code, we’d have to provide an argument for each possible answer, something like</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">[</span>child <span class=\"token keyword\">for</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>child <span class=\"token keyword\">for</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>child <span class=\"token keyword\">for</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>But we don’t have enough time or space for it. Fortunately there is a more compact formulation</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// return children depending on `n`</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>In this setting, a function acts like a big tuple whith a value for each possible answer expected from the operation. More formally, if <code class=\"language-text\">integer</code> is the type of integer expressions in our programming language, then we would say that <code class=\"language-text\">random</code> has an arity of <code class=\"language-text\">integer</code>. Observe also that the equivalence extends to finite arities as well. A binary operation <code class=\"language-text\">add(x,y)</code> can also be written as <code class=\"language-text\">add(b =&gt; b ? x : y)</code> and we can as well say that <code class=\"language-text\">add</code> has a <code class=\"language-text\">boolean</code> arity.</p>\n<p>There is nothing fancy here. From a programming point of view, the function passed to the operation is just a <em>continuation</em> that takes the answer from the performed operation and returns the rest of the program. It turns out that the continuation is a general representation for tuples of any arity.</p>\n<p>Just as we did with Monoids, we can use an interface each time we want to represent an Algebraic Theory. This would work well provided we have a sufficiently powerful type system to track side effects. We can also use a generic <code class=\"language-text\">operation</code> object to represent all possible operations in a program.</p>\n<p>More specifically, a program can be either</p>\n<ul>\n<li>A pure value that doesn’t perform any operation or side effect (a leaf)</li>\n<li>An Operation together with a continuation that specifies the rest of the program (a subtree)</li>\n</ul>\n<p>In typescript this would be something like (we could perhaps do safer than <code class=\"language-text\">any</code> but I’ll keep things simple)</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">;</span> value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span>\n      tag<span class=\"token operator\">:</span> <span class=\"token string\">\"operation\"</span>\n      name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n      params<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span>\n      <span class=\"token function-variable function\">resume</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">pure</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">,</span> value <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">operation</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span>\n  params<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">resume</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> pure\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"operation\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> resume <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>For example</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> random <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">operation</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"random\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// { tag: \"operation\", name: \"random\", params: [], resume: pure }</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Program<span class=\"token operator\">&lt;</span><span class=\"token keyword\">undefined</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"log\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>message<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// { tag: \"operation\", name: \"log\", params: [\"hello\"], resume: pure }</span></code></pre></div>\n<p>Obviously we can’t write entire programs in a single hard-coded giant expression tree. Observe that the <code class=\"language-text\">resume</code> parameter already defaults to the <code class=\"language-text\">pure</code> function, which means that by default the program performs the operation then returns the answer provided by the external environment.</p>\n<p>The default <code class=\"language-text\">pure</code> continuation allows us to create small truncated programs. what we need is a way to assemble bigger programs (trees) from smaller programs (subtrees). We can acheive this by exploiting the <em>binding</em> operation we saw earlier with simple math expressions. Binding will allow us to extend the program tree by replacing leaves (i.e. pure values) with further subtrees (rest of the program).</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">bind</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  program<span class=\"token operator\">:</span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">then</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">then</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> resume <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> program\n    <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> a <span class=\"token operator\">=></span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> then<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">bind</code> takes a program and a continuation. If the program is a leaf/pure value, we apply the contiuation immediately to get the rest of the program. This corresponds to ‘substitute a leaf with a subtree’ case. Otherwise we need to call <code class=\"language-text\">bind</code> recursively on all subtrees (in <code class=\"language-text\">a =&gt; bind(resume(a), then)</code>, think of <code class=\"language-text\">resume</code> as a big tuple: Each entry <code class=\"language-text\">resume(a)</code> in the tuple is replaced by <code class=\"language-text\">bind(resume(a), then)</code>).</p>\n<p>For example, going from <code class=\"language-text\">log(&quot;hello&quot;)</code> to <code class=\"language-text\">bind(log(&quot;hello&quot;), _ =&gt; random)</code> could be visually represented as</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 605px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/15f9c153d8719ed55fc8729fe86764ea/90cbd/expr-5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.177215189873415%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7CAAAOwgEVKEqAAAAAr0lEQVQoz21QCQ7DIAzj/19lVVsK5caT2cLYRqQoymUnVg+tse87cs5YWWutR2NOaK3hnPvrzaYIVGsdA9573PfdPaU06pyZc4m/oMoYA7o0SMBFeillDBLwOI8v8hWwuq6rA9bF+TOYsxbbtsFa14lWYIxqpZkMcJGXUjdKEVNCjLHnjPMH40IBEJ1ejYYQAmLk23loxxotvYEpj9RkX620oAv7hwQok36i5dzny0+yMCkUpGLK+gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Expression tree for random operation\"\n        title=\"Expression tree for random operation\"\n        src=\"/static/15f9c153d8719ed55fc8729fe86764ea/90cbd/expr-5.png\"\n        srcset=\"/static/15f9c153d8719ed55fc8729fe86764ea/c26ae/expr-5.png 158w,\n/static/15f9c153d8719ed55fc8729fe86764ea/6bdcf/expr-5.png 315w,\n/static/15f9c153d8719ed55fc8729fe86764ea/90cbd/expr-5.png 605w\"\n        sizes=\"(max-width: 605px) 100vw, 605px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>One more caveat is that writing programs using nested <code class=\"language-text\">bind</code>s is akin to writing in continuation passing style, which is tedious and impractical.</p>\n<p>First, let me clarify that the above implementation is just intented as a pedagogical tool. A real implementation of Algebraic Effects would typically be backed in by a programming language, not only to provide an ergonomic way for writing programs, but also to generate an efficient executable.</p>\n<p>We still would like to see how our tree representation maps to a traditional code written in a seqeuntial way. In the case of JavaScript, we can use Generator functions to create and bind programs using the sequential style. So for example one would write</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> fetchUser\n  <span class=\"token keyword\">let</span> repos <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> fetchRepos\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> user<span class=\"token punctuation\">,</span> repos <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>instead of</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>fetchUser<span class=\"token punctuation\">,</span> <span class=\"token parameter\">user</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>fetchRepos<span class=\"token punctuation\">,</span> <span class=\"token parameter\">repos</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> user<span class=\"token punctuation\">,</span> repos <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Below a simple (and ineffecient) implementation for transforming Generator functions into <code class=\"language-text\">bind</code> expressions, I won’t be commenting the code because the post is already getting long. The code supports resuming the <code class=\"language-text\">bind</code> continuation multiple times (which means the computation can take many paths in the tree).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">gf<span class=\"token punctuation\">,</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> history <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">gf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> history<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_<span class=\"token punctuation\">,</span> x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span>value\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token function\">go</span><span class=\"token punctuation\">(</span>gf<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">,</span> history<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> program <span class=\"token operator\">=</span> <span class=\"token function\">go</span><span class=\"token punctuation\">(</span>fetchData<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// // { tag: \"operation\", name: \"fetchUser\", params: [], resume: ... }</span></code></pre></div>\n<p>We’ve talked about construction, but what about evaluation? That where Handlers fit in the story. Handlers are typically presented as a generalisation of exception handlers that can resume the program from the point that threw the exception.</p>\n<p>In our declarative representation, a Handler is just another expression evaluator, like the one we saw earlier for Monoids.</p>\n<p>Let’s recall how we implemented the interpreter for our earlier Monoid theory. Given any Model for the Monoid theory, <code class=\"language-text\">fold</code> generates an interpreter for a monoid tree (the free model)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> fold<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>model<span class=\"token operator\">:</span> Monoid<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">tree<span class=\"token operator\">:</span> MTree<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> tree<span class=\"token punctuation\">.</span>value\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"zero\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">.</span><span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> interpreter <span class=\"token operator\">=</span> <span class=\"token function\">fold</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">zero</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> right<span class=\"token operator\">:</span> number<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> number <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> left <span class=\"token operator\">+</span> right\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">fold</code> first handles the <code class=\"language-text\">pure</code> case by returning the pure value (i.e. carrier value). Then for each operation, we start by recursively evaluating its children, then we use the model to recombine the computed values.</p>\n<p>Our programs are just expressions with a general notion of arity for the operations. So we can take the same implementation and adapt it.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">evaluate</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>program<span class=\"token operator\">:</span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Program<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"pure\"</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">.</span><span class=\"token keyword\">return</span> <span class=\"token operator\">?</span> model<span class=\"token punctuation\">.</span><span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> program\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> resume <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> program\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>name <span class=\"token keyword\">in</span> model<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>params<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> a <span class=\"token operator\">=></span> <span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The key thing here is the signature of the returned evaluator. It’s a transformation between computations: take a program in, and returns another program out. The returned program could be always a pure value, which means that all effects are <em>discharged</em>. The Model could also handles the effects by performing other effects (or even the same one raised by the input program).</p>\n<p>In our new interface, we’re dealing with generic operations, so we need to pass the operation’s parameters to the model. The model gets also a continuation representing the rest of the program (or the operation’s children). Just like <code class=\"language-text\">fold</code>, <code class=\"language-text\">handler</code> calls the evaluator recursively on the operations’s children (all <code class=\"language-text\">a =&gt; evaluate(resume(a))</code> calls).</p>\n<p>If our model doesn’t handle the current operation, then we <em>bubble</em> it up to upstream handlers. But in the meantime, the handler wraps itself around the operation. In the tree language, the model just ignores the operation node and tries to evaluate all its children instead.</p>\n<p>Finally, we allow the model to preprocess the return value of the program (the leaves) using a special method <code class=\"language-text\">return</code>. This is needed to allow the handler to change the return value of a program (like a handler for a program performing <code class=\"language-text\">state</code> effects can return stateful functions <code class=\"language-text\">state -&gt; [value, state]</code>. [Well, there is also more to this story. The Math formalism requires that the output program, which is also a Free Model, be also a Model for the Algebraic Theory implemented by the input program]).</p>\n<p>To highlight the analogy, here’s a reimplementation of Monoids using the new generic interface</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">zero</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zero\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">left<span class=\"token punctuation\">,</span> right</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"add\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">b</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">?</span> left <span class=\"token operator\">:</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> interpreter <span class=\"token operator\">=</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">zero</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resume</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">zero</code> is a nullary operation, just like the earlier <code class=\"language-text\">abort</code> example. The case of <code class=\"language-text\">add</code> is more interesting, it calls its continuation twice in order to reach both children. Like in the former implementation, the handler doesn’t bother with recursion and performs the addition directly on the results of <code class=\"language-text\">resume</code>, the recursion is taken care by <code class=\"language-text\">handler</code>.</p>\n<p>A key thing I’d like to emphasize: even if a programming language makes calling operations look like simple function invocations, it’s not the same. The distinction between pure values and effectful ones (often called computations) is core to the theory behind Algebraic Effects. In fact it’s core to any modeling of computational effects, including Monads (If it were not, we wouldn’t need fancy theories about side effects, simple mathematical functions would’ve been sufficient). What makes Algebraic Effects interesting (among other things) is that functions are typically polymorphic over Effects so one for example wouldn’t need a special <code class=\"language-text\">mapM</code> function like with Monads.</p>\n<p>By the way, if you have smelled the Monad in the above code, it’s because our programs are rightly instances of a Monad (It’s much more flexible than the usual Monads and so called the <code class=\"language-text\">Freer Monad</code>). You could also apply the Tree intuition in the case of Monads as well.</p>\n<p>There’s more to be said like the relation between Algebraic Theories and Monads, maybe for a future post. In the meantime, I hope the post gave you a better intuition on the relation between Algebra and side effects.</p>\n<h1>Resources</h1>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1807.05923\">What is algebraic about algebraic effects and handlers?</a></li>\n<li><a href=\"http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html?m=1\">Monads are Trees with Grafting</a></li>\n<li><a href=\"http://okmij.org/ftp/Haskell/extensible/exteff.pdf\">Extensible Effects</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=6t6bsWVOIzs\">A Categorical View of Computational Effects</a></li>\n</ul>","frontmatter":{"title":"Algebraic Effects: from Algebra to Programs","date":"June 26, 2021","description":null}},"previous":{"fields":{"slug":"/2021-01-20-react-callbacks/"},"frontmatter":{"title":"A simple rule for using callbacks in React"}},"next":{"fields":{"slug":"/2023-09-04-pat/"},"frontmatter":{"title":"Types as Propositions in Typescript"}}},"pageContext":{"id":"540d8f61-3608-5d8a-9ecd-728cee3c8b91","previousPostId":"7e9e5ba2-d552-5015-a2c2-9bec2f345e63","nextPostId":"059e6e0b-110e-5280-970f-5a2bf71936a6"}},"staticQueryHashes":["2841359383","3257411868"]}