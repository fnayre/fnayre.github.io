{"componentChunkName":"component---src-templates-blog-post-js","path":"/2023-09-04-pat/","result":{"data":{"site":{"siteMetadata":{"title":"Abstract fun"}},"markdownRemark":{"id":"059e6e0b-110e-5280-970f-5a2bf71936a6","excerpt":"Propositions as types correspondance (PAT) (or Types as Propositions) is one of the most \nintriguing discoveries of Computer Science. The gist of it is: In…","html":"<p>Propositions as types correspondance (PAT) (or Types as Propositions) is one of the most\nintriguing discoveries of Computer Science. The gist of it is:</p>\n<ul>\n<li>In Logic land, you often see stuff like <code class=\"language-text\">P is True</code>. Here, <code class=\"language-text\">P</code> can stand for some\nstatement that can be true or false. And a Proof is constructed to back the statement.</li>\n<li>In code, we’ve got something like: <code class=\"language-text\">let x: T = term;</code>.</li>\n</ul>\n<p>The correspondance is basically saying Logic and Programming are two sides of the same coin:</p>\n<ul>\n<li>In Logic: When you claim something is true, you must provide a Proof for it.</li>\n<li>In code: If you got a type and want to use it, you create a term of that type.</li>\n</ul>\n<p>It’s as if we were writing <code class=\"language-text\">let x: P = proof;</code> in TypeScript. And it’s not just some\nquirky coincidence. If we restrict ourself to a pure subset TypeScript, you’ll see\nyou can write logical proofs using code.</p>\n<h2>Code’s Take on Logic Constructs</h2>\n<p>First let’s review quickly the key concepts in Logic, they work pretty much like the booleans\nwe use in programming:</p>\n<ul>\n<li><code class=\"language-text\">True</code> or <code class=\"language-text\">⊤</code>: This represents a proposition that’s always true. </li>\n<li><code class=\"language-text\">False</code> or <code class=\"language-text\">⊥</code>: signifies something that’s never true.</li>\n<li><code class=\"language-text\">A ∨ B</code> : A disjunction. True if either <code class=\"language-text\">A</code> or <code class=\"language-text\">B</code> hold true. Could be both.</li>\n<li><code class=\"language-text\">A ∧ B</code> : A conjunction. Both <code class=\"language-text\">A</code> and <code class=\"language-text\">B</code> must be true.</li>\n<li><code class=\"language-text\">A -&gt; B</code> : Logical implication. If <code class=\"language-text\">A</code> is true, then <code class=\"language-text\">B</code> is consequently true.</li>\n<li><code class=\"language-text\">!A</code> : negation, a Proposition that’s true if <code class=\"language-text\">A</code> is not.</li>\n</ul>\n<p>There’s also <code class=\"language-text\">A &lt;=&gt; B</code>. It’s essentially stating that <code class=\"language-text\">A</code> implies <code class=\"language-text\">B</code> and <code class=\"language-text\">B</code> implies <code class=\"language-text\">A</code>.\nIn other words, <code class=\"language-text\">(A -&gt; B) ∧ (B -&gt; A)</code>. </p>\n<p>Now for each one of the above constructs we have an equivalent type in Typescript.</p>\n<p><code class=\"language-text\">True</code> corresponds to any inhabitated type</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">True</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">;</span></code></pre></div>\n<blockquote>\n<blockquote>\n<p>We could use a singleton type like <code class=\"language-text\">null</code> or <code class=\"language-text\">undefined</code>. But with the <code class=\"language-text\">unknown</code> type,\nwe can assign any value to it.</p>\n</blockquote>\n</blockquote>\n<p><code class=\"language-text\">False</code> translates to an uninhabited type in TypeScript. This mirrors the fact that there’s no\nproof for a false proposition in Logic:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">False</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">A ∨ B</code> corresponds to a discriminated union type in TypeScript. </p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Or<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> \n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"left\"</span><span class=\"token punctuation\">;</span> value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">}</span> \n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"right\"</span><span class=\"token punctuation\">;</span> value<span class=\"token operator\">:</span> <span class=\"token constant\">B</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>We’ll also write two constructor functions:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">left</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Or<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">never</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"left\"</span><span class=\"token punctuation\">,</span> value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">right</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Or<span class=\"token operator\">&lt;</span><span class=\"token builtin\">never</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> <span class=\"token string\">\"right\"</span><span class=\"token punctuation\">,</span> value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And a helper for case analysis:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">either</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  or<span class=\"token operator\">:</span> Or<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">onLeft</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">C</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">onRight</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">C</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">C</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    or<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"left\"</span> \n      <span class=\"token operator\">?</span> <span class=\"token function\">onLeft</span><span class=\"token punctuation\">(</span>or<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span> \n      <span class=\"token operator\">:</span> <span class=\"token function\">onRight</span><span class=\"token punctuation\">(</span>or<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">A ∧ B</code> corresponds to a pair of types:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">And<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Logical implications translate to function types:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Imp<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">B</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Finally, The equivalence <code class=\"language-text\">A &lt;=&gt; B</code> corresponds to a pair of 2 functions.\nIt’s a sort of 2-way conversion between <code class=\"language-text\">A</code> and <code class=\"language-text\">B</code></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Iff<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>Imp<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Imp<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>So far, everything’s been kinda familiar, right? But with negation, things are getting a bit wild.</p>\n<h2>Negative types</h2>\n<p>Let’s start by unpacking the meaning of <code class=\"language-text\">False</code>/<code class=\"language-text\">never</code>. The <code class=\"language-text\">never</code> type acts as a universal subtype,\nas it can be assigned to any other type.</p>\n<p>You might wonder about the meaning of <code class=\"language-text\">any</code> here. Intriguingly, <code class=\"language-text\">any</code> stands as a proposition\nthat is both <code class=\"language-text\">True</code> and <code class=\"language-text\">False</code> at once. This duality allows any value to be assigned to it,\nmaking it akin to <code class=\"language-text\">unknown</code> or <code class=\"language-text\">True</code>. On the flip side, it can fit into any type (except <code class=\"language-text\">never</code>),\nreflecting the nature of <code class=\"language-text\">never</code> or <code class=\"language-text\">False</code>.</p>\n<p>In logical discourse, a proposition that holds as true and false simultaneously is labeled\na <em>contradiction</em>. If one can prove a contradiction,  the whole logic system just falls apart.\nIn a parallel sense, being able to produce terms of type <code class=\"language-text\">any</code> compromises the\nsoundness of the type system. As highlighted in the TypeScript documentation, the\nflexibility of <code class=\"language-text\">any</code> sacrifices type safety. </p>\n<p>This brings us to the concept of <strong>Proof by contradiction</strong>: To disprove a proposition <code class=\"language-text\">A</code>\n(or to assert <code class=\"language-text\">!A</code>), one assumes <code class=\"language-text\">A</code> is true and then demonstrates that this assumption leads\nto a contradiction.. In essence, <code class=\"language-text\">!A</code> equates to <code class=\"language-text\">A -&gt; False</code>.</p>\n<p>Hence, negating a type <code class=\"language-text\">A</code> in TypeScript translates to the function <code class=\"language-text\">(x: A) =&gt; never</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Not<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Double negation, paradoxes and the halting problem</h2>\n<p>Constructing a term of type <code class=\"language-text\">A -&gt; never</code> poses challenges though. How can we return a <code class=\"language-text\">never</code> value when,\nby definition, <code class=\"language-text\">never</code> lacks any values?</p>\n<p>One way to produce a negative type in Typescript is by writing a non terminating function. For example: </p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">forever</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">forever</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// typeof forever = &lt;A>(a: A) => never</span></code></pre></div>\n<p>Typesript detects that the function never terminates and assigns to it a type of <code class=\"language-text\">&lt;A&gt;(a: A) =&gt; never</code>.\n(There are alternative methods to create functions that don’t return,\nbut remember we’re operating within a limited TypeScript subset here).</p>\n<p>Is this type designation genuinely <em>accurate</em> from a logical standpoint?</p>\n<p>Consider the following function</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">double_neg</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">ff</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token function-variable function\">callback</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">wait_forever</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">never</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">wait_forever</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">ff</span><span class=\"token punctuation\">(</span>wait_forever<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>A closer look at the type reveals it corresponds to <code class=\"language-text\">Not&lt;Not&lt;A&gt;&gt; =&gt; A</code>. This is just the <em>double\nnegation law</em> in Logic: <code class=\"language-text\">!!A = A</code>. </p>\n<p>The implementation exploits the fact that <code class=\"language-text\">never</code> can be assigned to any type <code class=\"language-text\">A</code>. Now we should\nbe able to use our double negation in our code to turn values of type <code class=\"language-text\">!!A</code> into values of type <code class=\"language-text\">A</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token function\">double_neg</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=></span> <span class=\"token function\">k</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span></code></pre></div>\n<p>However an issue arises:  the statement <code class=\"language-text\">let b = a + 2;</code> is never reached. Upon entering <code class=\"language-text\">double_neg</code>, the body\ninvokes <code class=\"language-text\">k(5)</code> where <code class=\"language-text\">k</code> represents the non terminating function <code class=\"language-text\">wait_forever</code>. The program remains trapped\nthere indefinitely.</p>\n<p>The core issue with <code class=\"language-text\">wait_forever</code> is its endless recursion. It’s like an infinite loop that keeps\nrunning without an exit condition. In Logic, infinite loops can give birth to tricky paradoxes,\nlike this classic:</p>\n<blockquote>\n<blockquote>\n<p>This statement is false</p>\n</blockquote>\n</blockquote>\n<p>This is the essence of the <em>liar paradox</em>. If you try to reason through it, you’ll get stuck in\na endless cycle of contradictions. Give it a try!</p>\n<ol>\n<li><strong>If we assume that <code class=\"language-text\">statement</code> is true</strong>, then the statement\nmust be false as it claims to be. But then it contradicts our own assumption that\nthe statement was true.</li>\n<li><strong>If we assume that <code class=\"language-text\">statement</code> is false</strong>, then it’s ironically being truthful\nabout its falsehood, making it true. Again, this is a contradiction because we\njust assumed it was false.</li>\n</ol>\n<p>The self-referencing nature of the statement is the real troublemaker here. It creates a\nloop where the truth value keeps toggling between true and false, never settling, similar\nto how a piece of code is stuck in an infinite loop.</p>\n<p>This is bad for Logic, which requires every proof to be finite. What this says in reality is\nthat <code class=\"language-text\">wait_forever</code> is not exactly the function we’re seeking for our negative types.</p>\n<p>A more Logic freindly interpretation of negation is actually possible, and would allow writing programs\nin <em>double negation style</em>. To see how, let’s revisit our earlier example:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token function\">double_neg</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=></span> <span class=\"token function\">k</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span></code></pre></div>\n<p>The double negation principle, <code class=\"language-text\">!!A = A</code>, hints that the program should progress beyond the initial line,\nassigning a number type to <code class=\"language-text\">a</code>. Which number? In this context, <code class=\"language-text\">5</code> seems like a logical choice.</p>\n<p>But then, what’s the role of the <code class=\"language-text\">k</code> argument, and how do we instantiate it?</p>\n<p>Here’s the twist: <code class=\"language-text\">k</code> isn’t a function we can implement by ourselves. <strong>It has to be provided</strong>\nto us by the programming language.</p>\n<p>This isn’t just a normal function, It belongs to a special\nclass known as <em>continuations</em>. Think of a continuation as a snapshot of a program’s\nfuture from a particular moment. For example, consider this code:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// assume f : (n: number) => number</span>\n<span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span></code></pre></div>\n<p>Now, let’s transform it into a continuation-passing style (CPS):</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>In the CPS style, every function receives an extra <code class=\"language-text\">k</code> argument, which represents the program’s subsequent steps.</p>\n<p>Our <code class=\"language-text\">double_neg</code>, by converting from <code class=\"language-text\">Not&lt;Not&lt;A&gt;&gt;</code> to <code class=\"language-text\">A</code>, essentially transforms a CPS function call into\na standard value of type <code class=\"language-text\">A</code>. It achieves this by encapsulating the program’s future steps and repackaging\nthem into a function awaiting a value to proceed.</p>\n<p>While non-terminating functions and continuations both return <code class=\"language-text\">never</code>, continuations avoid\nembedding self-referential inconsistencies <strong>within</strong> our system. By the time the\nfunction concludes, the program has also concluded.</p>\n<p>That means to make values of type <code class=\"language-text\">Not&lt;A&gt;</code>, our programming language should equip us with\nsomething to encapsulate the program’s subsequent steps as a continuation. </p>\n<p>Although TypeScript doesn’t natively support this construct, for the sake of discussion,\nlet’s pretend it does:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">double_neg</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> Not<span class=\"token operator\">&lt;</span>Not<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">>></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">;</span></code></pre></div>\n<blockquote>\n<blockquote>\n<p>While the double negation principle might feel intuitive, I should mention it’s not something\nuniversally accepted. Some logicians believe that just because a statement isn’t proven doesn’t\nmean the opposite holds true. Think of it as “absence of evidence isn’t evidence of absence.”\nThis viewpoint is held by <em>intuitionistic logic</em>.</p>\n<p>In contrast <em>classical Logic</em> embraces the double negation law. But as we’ve observed,\nto embed this principle in a programming language, we need a control operator to\nturn double negation into identity. This hints at a deep connection between the context\nin which a program runs and the foundational logic underpinning it.</p>\n</blockquote>\n</blockquote>\n<p>If you’ve dabbled with Lisp-like languages (like Scheme or Clojure), you might’ve bumped\ninto a cousin of <code class=\"language-text\">double_neg</code> named <code class=\"language-text\">call/cc</code> (though its type is a bit different).</p>\n<h2>Diving into Logical Proofs using TypeScript</h2>\n<p>Having established a bridge between Logic’s concepts and our TypeScript subset,\nWe’re ready to weild this knowledge to perform some common proofs in Logic.</p>\n<p>The most elementary proof is the tautology <code class=\"language-text\">A =&gt; A</code>. This is just the identity function</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">id</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Let’s see some more interesting proofs.</p>\n<p>We’ll define all our proofs in a generic function, to abstract over propostions <code class=\"language-text\">A</code> and <code class=\"language-text\">B</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">context</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//</span>\n  <span class=\"token keyword\">type</span> <span class=\"token class-name\">NotA</span> <span class=\"token operator\">=</span> Not<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">type</span> <span class=\"token class-name\">NotB</span> <span class=\"token operator\">=</span> Not<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// ... subsequent proofs will be populated here</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Law of Excluded Middle (<code class=\"language-text\">A ∨ !A &lt;=&gt; True</code>)</h3>\n<p>The law of excluded middle is a foundational principle in classical logic,\nwhich asserts that any proposition is either true or its negation is true.\nThere’s no in-between state.</p>\n<p>Let’s first write the implementation:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// A ∨ !A</span>\n<span class=\"token keyword\">const</span> excluded_middle<span class=\"token operator\">:</span> Or<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> NotA<span class=\"token operator\">></span> <span class=\"token operator\">=</span> \n  <span class=\"token function\">double_neg</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=></span> \n    <span class=\"token function\">k</span><span class=\"token punctuation\">(</span><span class=\"token function\">right</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> \n      <span class=\"token function\">k</span><span class=\"token punctuation\">(</span><span class=\"token function\">left</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>To construct a value of type <code class=\"language-text\">A ∨ !A</code>, we have 2 choices:</p>\n<ol>\n<li>Constructing <code class=\"language-text\">A</code>: Creating an instance of an arbitrary type <code class=\"language-text\">A</code> is unfeasible.\nIt’s like attempting to materialize something from nothing.</li>\n<li>On the other hand, creating an instance of <code class=\"language-text\">!A</code> is feasible. To understand\nthis, recall that <code class=\"language-text\">!A</code> is synonymous with a continuation of type <code class=\"language-text\">(a:A) -&gt; never</code>.\nSo we’ll need the help of <code class=\"language-text\">double_neg</code>.</li>\n</ol>\n<p>Here’s the step-by-step breakdown of the implementation:</p>\n<ol>\n<li>Invoke <code class=\"language-text\">double_neg</code> and capture the current continuation as <code class=\"language-text\">k</code>.</li>\n<li>Inside the continuation, the next plausible action is to make use\nof <code class=\"language-text\">right</code> to indicate we’re choosing the negation path. This gives: <code class=\"language-text\">k(right(a =&gt; _))</code>.</li>\n<li>Now, inside our function <code class=\"language-text\">(a =&gt; _)</code>, we need to return a value of type <code class=\"language-text\">never</code>.\nThe one tool we have at our disposal to achieve this effect is the captured\ncontinuation <code class=\"language-text\">k</code>. Since we now have access to a value of type <code class=\"language-text\">A</code> (through the function argument),\nwe can use <code class=\"language-text\">k</code> to redirect our flow to the other branch, i.e., <code class=\"language-text\">left(A)</code>.\nThis is expressed as: <code class=\"language-text\">k(left(a))</code>.</li>\n</ol>\n<p>This construction can look mind-bending, especially if encountered for\nthe first time. It’s somewhat analogous to a closed time-like loop in physics,\nwhere cause and effect blur.</p>\n<p>In <a href=\"https://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf\">one of his papers</a>, Philipe Wadler,\nillustrates the above behavior:</p>\n<blockquote>\n<blockquote>\n<p>The following story illustrates this behavior. (With apologies to Peter Selinger,\nwho tells a similar story about a king,\na wizard, and the Philosopher’s stone.)</p>\n<p>Once upon a time, the devil approached a man and made\nan offer: “Either (a) I will give you one billion dollars, or (b)\nI will grant you any wish if you pay me one billion dollars.\nOf course, I get to choose whether I offer (a) or (b).</p>\n<p>The man was wary. Did he need to sign over his soul?\nNo, said the devil, all the man need do is accept the offer.</p>\n<p>The man pondered. If he was offered (b) it was unlikely\nthat he would ever be able to buy the wish, but what was\nthe harm in having the opportunity available?\n“I accept,” said the man at last. “Do I get (a) or (b)?”\nThe devil paused. “I choose (b).”</p>\n<p>The man was disappointed but not surprised. That was\nthat, he thought. But the offer gnawed at him. Imagine\nwhat he could do with his wish! Many years passed, and\nthe man began to accumulate money. To get the money he\nsometimes did bad things, and dimly he realized that this\nmust be what the devil had in mind. Eventually he had his\nbillion dollars, and the devil appeared again.</p>\n<p>“Here is a billion dollars,” said the man, handing over a\nvalise containing the money. “Grant me my wish!”\nThe devil took possession of the valise. Then he said,\n“Oh, did I say (b) before? I’m so sorry. I meant (a). It is\nmy great pleasure to give you one billion dollars.”</p>\n<p>And the devil handed back to the man the same valise\nthat the man had just handed to him.</p>\n</blockquote>\n</blockquote>\n<p>Lastly, an important takeaway is that the <code class=\"language-text\">double_neg</code> function anchors this logic\nin the domain of classical logic. In intuitionistic logic, which is more conservative\nabout claims of truth or falsity, such a construction might not hold true. Here,\nif you cannot furnish a proof for <code class=\"language-text\">A</code>, it doesn’t automatically mean <code class=\"language-text\">A</code> is false.\nIt simply means that the truth value of <code class=\"language-text\">A</code> remains undetermined.</p>\n<h3><code class=\"language-text\">A ∧ !A -&gt; False</code></h3>\n<p>A proposition and its negation cannot both be true simultaneously.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// A ∧ !A -> False</span>\n<span class=\"token keyword\">const</span> neg_law<span class=\"token operator\">:</span> Imp<span class=\"token operator\">&lt;</span>And<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> NotA<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> False<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> notA<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">notA</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In code, this means we can just smash matter and antimatter together and\nwatch them annihilate.</p>\n<h3>Are Functions Essentially Discriminated Unions?</h3>\n<p>Here’s a thought-provoking equivalence:</p>\n<p><strong><code class=\"language-text\">A -&gt; B &lt;=&gt; !A ∨ B</code></strong></p>\n<p>It basically says a function <code class=\"language-text\">A -&gt; B</code> is equivalent to an union of a\ncontinuation expecting <code class=\"language-text\">A</code> and a value <code class=\"language-text\">B</code>.</p>\n<p>Let’s see what this means in code.</p>\n<p>From <code class=\"language-text\">(A -&gt; B)</code> to <code class=\"language-text\">(!A ∨ B)</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Transition from (A -> B) to (!A ∨ B)</span>\n<span class=\"token keyword\">const</span> fn_union_fwd<span class=\"token operator\">:</span> Imp<span class=\"token operator\">&lt;</span>Imp<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Or<span class=\"token operator\">&lt;</span>NotA<span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">>></span> <span class=\"token operator\">=</span> \n  <span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token function\">double_neg</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=></span> \n      <span class=\"token function\">k</span><span class=\"token punctuation\">(</span><span class=\"token function\">left</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> \n        <span class=\"token function\">k</span><span class=\"token punctuation\">(</span><span class=\"token function\">right</span><span class=\"token punctuation\">(</span>\n          <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Utilizing the previous time-traveling maneuver, we initially yield a continuation\nto solicit an <code class=\"language-text\">A</code> type. Then we use our <code class=\"language-text\">A -&gt; B</code> function to transform the <code class=\"language-text\">A</code> into a <code class=\"language-text\">B</code> value.\nSubsequently, we reinvoke the continuation to yield the result <code class=\"language-text\">B</code> to the surroundings.</p>\n<p>Conversely, for the transformation of a union type to a function:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Transition from (!A ∨ B) to (A -> B)</span>\n<span class=\"token keyword\">const</span> fn_union_bwd<span class=\"token operator\">:</span> Imp<span class=\"token operator\">&lt;</span>Or<span class=\"token operator\">&lt;</span>NotA<span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Imp<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">>></span> <span class=\"token operator\">=</span> \n  notA_or_B <span class=\"token operator\">=></span> \n    a <span class=\"token operator\">=></span>\n      <span class=\"token function\">either</span><span class=\"token punctuation\">(</span>\n        notA_or_B<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">(</span>notA<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">notA</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> b<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>To morph a union type to a function, we assume an <code class=\"language-text\">A</code> argument. Then based on the\ncontent of our container <code class=\"language-text\">!A ∨ B</code>:</p>\n<ul>\n<li>If it’s a continuation waiting for an <code class=\"language-text\">A</code>, we just present our <code class=\"language-text\">A</code> argument.</li>\n<li>Conversely, if it’s a <code class=\"language-text\">B</code> value, we directly return it.</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>This may appear as a form of trickery. One usually expects a genuine mechanism\nto turn an <code class=\"language-text\">A</code> into a <code class=\"language-text\">B</code>. Instead, the transformation feels more like\nrouting around the union, merely forwarding existing information rather than\ntruly processing it.</p>\n<p>To be honest, I don’t really have a plausible explanation. I was thinking it might be because\nof classical logic quirks, but the above proof doesn’t use <code class=\"language-text\">double_neg</code> so it’s equally\nvalid in intuitionistic logic. </p>\n<p>I tried to ask my freind GPT-4. Can’t say it adds much but here’s the answer anyway:</p>\n<p>“Imagine you have a box that might either contain a machine that needs some input <code class=\"language-text\">A</code>\nto work or an already finished product <code class=\"language-text\">B</code>. Now, if someone hands you an <code class=\"language-text\">A</code>, this function\nsimply checks the box. If there’s a machine (<code class=\"language-text\">notA</code>), it feeds the <code class=\"language-text\">A</code> to it.\nIf there’s a finished product <code class=\"language-text\">B</code>, it just hands it over. The function doesn’t\ndo the “creation” part itself, but instead relies on what’s in the box. This doesn’t\nfeel like a trick anymore; it’s more about delegation and routing based on what’s available.”</p>\n</blockquote>\n</blockquote>\n<p>Wrapping up, I hope you found this dive as intriguing! If your curiosity is still piqued,\nconsider tackling these additional equivalences:</p>\n<p>I’ve put a <a href=\"https://www.typescriptlang.org/play?#code/PTAEDMEMBsGcFNQAcBOB7JbYEsAu20A7UQUqIAoXATyUQBUUBXRAXlAcIGtC0B3QgbjJkQoXI0SoMWPAWKASogrVEAMRgJQrQvABu8FIOFgAItlgArdgGN8RUAEFQgCiJQAIUU1QAeRQAeOwBpXAD4NUDJQUAAfUABvUUgAcwAuUAAiaHhwXFT+UG0YJhSHAF8wiOi43ESU1JRsBIALbNz86ELXUGKDMnArG2IMrL8ggApW9rsAShTvP0CtXRQQmPDQFHhcBhRiSuq0wezA8cQusmKhXsJrWTX6pp8XUeOUl2mvXwW9QMfY1fXN7axeLJNJ1RqHPIFE6Cc49Po3eB4Bp6OauQIAYVGqzQKBmvgCwX82MIABlMrgUiNIEVJhoQuiiREiAAlO4U0AjABGL1pzHpRLe6N+fw2W2II1WTJQADoqgkNMxWOlyakyhF1QB+UBEMlZEY46XHWmS9UpFls-Uyo2rSYwoSGUDoogWK79eygQDkRK53Ig7IQACaon6sADaBJcAF1uiIAJIAWyQ0GwlkgbocAFoQm4qB540ggyFWFSaXTXAYRABRACODGwrXgV19oB8fO9OcQMfA4ALoRDeYLgX7LkCdiCUaEIgAcvAEqmbgBCOw+0CTtC4YahEYADxLrc++ntImU2BQsFwoFTuHgCfPuDQyHQ-oYlkQkBXM7nulESjhrpuUGwDJ-QAfS0BJgMva8kFwEZaRWVZLmuWxwBxHQUVHYt7Dgk1-jFCBUMWKlbVWUohAids0HAfD1kWVYRHVAA9DV7QiRC3X9NAGE5DJQJnYYRi7SkU2gaBOUgSwOEpaksNLfdeRCOSil+dVQBAE02JuHhIDwYCUJovRMKmFJ92UlS1lFQEtJ0vS0JQIjBBU2EVNwwEuxGKzcF0gi9GIiJznIpRKNADiuJ4sC6LARjmIiejsEQVd1wS4YgjI0AMnPaTCAYONOT0UIQu4+BeISEYOFLDgRgAVkmYjVnS0BuVALKcry1g3wAalAAAmO0JzAJ0UHWaxgs4wqmo-N04wYM8GokdBtGwf14H9URkQfNAEhQSA4zjbBCHlaBIH2hhEngMglssQ71ggeFbAKsK+Iw8AUiSpLRyCN47HLMAYyWwh8CoNLIB4d1WyXDTbEW-jpKmUyXOISBepEABlNA40QSw0bjWxJEo2BQD20ASQ25NfyQ4hrC3AtYNMtSAo8BKHFYN6ggMen4rXFxQiSx42dUgAqQWheFkXRbF0BfobAHKCJ4H8bFhXFZF4BUvohxnFUOBEBbEIlwiTHCBmxapbwShgMOnhgIARhSTtu1mAlNYQIIR0LUAQ1SmKwHV0AncQTN7BNEY7BxP35NARFcGROyQ5QP3AkWwJIE5WAthW1tk9TlB-UmIkTREDNdacX21DOlSiNLA4iMZUBxwi90vXoJhmzB1YDaNv7pfN4HgK622uz8ANUSb+AXfsN2Pfz73PVAEfQADvX1SpANw6O-0QwABgjPOVIL+ei8b8Qg8gcOQ0geYGBE7fVjrmKlfvh-H6fhWVbo5-FffWc3Qt+X34flWIj1xJMDbUVEo6IHgFuS6DAlorV2v6f0GR64+0XG3IgM1IHQNgcBeBiD4B4lRIzN2Jp7pFTAqVUsJoIgVTBE0KklCzLqgqlXE+kwqGgBqiaWqXsG6gEXPvEuWs0GG3PGBbuPBbYJkHoGAkRDAh+zdiMM+8w1x2AjOHbguA7D2WEH-PR+jH6vzvu-UARhEAAFkcSzkIAAcnxsAngv8DFiwAapMA85g7F1eC3EI-CvTzjcPrdB54lrYxQNY62-duxJQdt8IIY8-SBhZoEHm8SJ5Tz4Z45w3iA5+L4YEpeCVgKx28a2D2jCIgV1bEUkpIwWE1UCOwypnJw41JxC4EYtCYItLYYw6+jCRB5ICQIjxPtXjsKUZogkmjIzh2Du08Okdo7zJQMOJqqiVG4FeDXOu9dRkz28TrPhKCClHhxFpbOwUTzwHJpkhwXocm+JOcImaoSrFHS6rpHg-pJH5jekPcM8TAizEZikzm8TQirBGDUtepSUoqVIcVChrZ2HMPJPQlFFTQA0ItJyBhWKVxrmKbCpR58GrqKaRw3pZlOEqV8mqEQLhxIcAuStf01zbn8OcMM3JniHnUvbiE687zCCfM5N835PgQUbMJVsse-yZFxIhcwIOjMcQJThUHZR5L5LsKWQZSlaqUAaprowkYUyNGqOrpS81nNLVbK5Lndh9LAEvKFWE6xfcJYDwVQWMe0qtFgrlRPN54SPlfP9IEUNnrgLiv9BGN+zik3Jv5q-RN99QDVlrPWRsN0-y2AAGRsEILIJxBijFuPdAHLmRyuXeh4coc5kBLnsqGm6Tx1baQBxGHW8ZQSREQEIMBdgsgI2Sv7IC4FvhQXBGIeXSAXUWl0nYYi8hZVMUVLRXqN8G6sU4vBBKAl6oF2ciIpSiItKKmXrpXzRlzLWVXLbTcHtYyu0hA7VmAVwTB3DpLUQWNEqJZSIDZOoD+ZAVzvVFM4COJgJc13ce5dWL9V2XPesrRMGUBwdNRU21Wj7XaJPjhs1S7WycmI+qbhoBBU-pHf++AVYok+AnXEqdPgZ2PAnuAIddGh3gG+YEbjv7R1xoTbCe0QggA\">TS playground</a>\nWhere you can find other common proofs in Logic.</p>\n<p>Happy proving!</p>","frontmatter":{"title":"Types as Propositions in Typescript","date":"September 05, 2023","description":null}},"previous":{"fields":{"slug":"/2021-06-26-algebraic-effects-trees/2021-06-26-algebraic-effects-trees/"},"frontmatter":{"title":"Algebraic Effects: from Algebra to Programs"}},"next":null},"pageContext":{"id":"059e6e0b-110e-5280-970f-5a2bf71936a6","previousPostId":"540d8f61-3608-5d8a-9ecd-728cee3c8b91","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}